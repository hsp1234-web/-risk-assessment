# Step 1: Install yfinance if it's not already part of the Colab environment (usually it is)
# !pip install yfinance pandas

# Step 2: Import necessary libraries
import yfinance as yf
import pandas as pd
import ipywidgets as widgets
from ipywidgets import VBox, HBox, Layout
from IPython.display import display, clear_output
from google.colab import files # For downloading files in Colab

# Step 3: Define data and global-like variables for state management

# --- Data and Configuration ---
TICKER_SYMBOL = "^TWII"
INDEX_NAME = "台灣加權指數 (TAIEX)"

VALID_INTERVALS = {
    "1m": "1 分鐘線 (Yahoo通常僅回溯最近 7 個交易日, period='max')",
    "2m": "2 分鐘線 (Yahoo通常僅回溯最近 60 個日曆日, period='max')",
    "5m": "5 分鐘線 (Yahoo通常僅回溯最近 60 個日曆日, period='max')",
    "15m": "15 分鐘線 (Yahoo通常僅回溯最近 60 個日曆日, period='max')",
    "30m": "30 分鐘線 (Yahoo通常僅回溯最近 60 個日曆日, period='max')",
    "60m": "60 分鐘線 (同1h, Yahoo通常回溯最近 730 個日曆日, period='max')",
    "1h": "1 小時線 (Yahoo通常回溯最近 730 個日曆日, period='max')",
    "1d": "日線 (可獲取最長可用歷史)",
    "5d": "5 日線 (每筆數據代表5個交易日的聚合)",
    "1wk": "週線 (可獲取最長可用歷史)",
    "1mo": "月線 (每筆數據代表1個月)",
    "3mo": "季線 (每筆數據代表3個月)"
}
INTERVAL_OPTIONS_DISPLAY = list(VALID_INTERVALS.values())
DESCRIPTION_TO_KEY_MAP = {v: k for k, v in VALID_INTERVALS.items()}

# --- Global-like variables to store fetched data and interval key ---
fetched_data_df = None
fetched_interval_key_for_filename = None # To store the interval key for filename generation

# Step 4: Define UI Elements

# --- UI Elements ---
title_label = widgets.HTML(f"<h2>{INDEX_NAME} ({TICKER_SYMBOL}) 歷史量價數據下載工具</h2>")
info_label = widgets.HTML(
    "<p><b>說明：</b>本工具將嘗試從 Yahoo Finance 下載您所選時間週期的「最長可用」歷史數據。<br>"
    "請先「抓取資料」，成功後即可選擇下載 CSV 或 TXT 格式的檔案。</p>"
)

interval_label = widgets.Label("選擇時間週期 (K線間隔):")
interval_dropdown = widgets.Dropdown(
    options=INTERVAL_OPTIONS_DISPLAY,
    value=VALID_INTERVALS["1d"], # Default to daily
    description='',
    disabled=False,
    layout=Layout(width='80%')
)

fetch_data_button = widgets.Button(
    description="1. 抓取資料",
    disabled=False,
    button_style='primary',
    tooltip='點擊以抓取所選週期的數據',
    icon='search',
    layout=Layout(width='auto', margin='10px 0 0 0')
)

# Download buttons container (initially hidden)
download_buttons_container = HBox([], layout=Layout(margin='10px 0 0 0', visibility='hidden'))

download_csv_button = widgets.Button(
    description="下載 CSV (.csv)",
    disabled=True,
    button_style='success',
    tooltip='數據準備好後，點擊此處下載CSV檔案',
    icon='table',
    layout=Layout(width='auto', margin='0 5px 0 0') # Right margin for spacing
)

download_txt_button = widgets.Button(
    description="下載 TXT (.txt)",
    disabled=True,
    button_style='info',
    tooltip='數據準備好後，點擊此處下載TXT檔案',
    icon='file-text-o', # FontAwesome icon for text file
    layout=Layout(width='auto', margin='0 0 0 5px') # Left margin for spacing
)
download_buttons_container.children = [download_csv_button, download_txt_button]


output_area = widgets.Output(layout=Layout(border='1px solid #ccc', padding='10px', width='98%', height='350px', overflow_y='auto', margin='10px 0 0 0'))

# Step 5: Define Button Click Handlers

def on_fetch_data_button_clicked(b):
    global fetched_data_df, fetched_interval_key_for_filename # Declare usage

    with output_area:
        clear_output(wait=True)
        print("初始化抓取程序...")

        # Reset state
        fetched_data_df = None
        fetched_interval_key_for_filename = None
        download_csv_button.disabled = True
        download_txt_button.disabled = True
        download_buttons_container.layout.visibility = 'hidden'
        fetch_data_button.disabled = True

        selected_description = interval_dropdown.value
        interval_key = DESCRIPTION_TO_KEY_MAP.get(selected_description)

        if not interval_key:
            print("錯誤：無效的時間週期選擇。")
            fetch_data_button.disabled = False
            return

        fetched_interval_key_for_filename = interval_key # Store for later use in filename

        print(f"準備抓取 {INDEX_NAME} ({TICKER_SYMBOL})")
        print(f"選擇的時間週期: {interval_key} ({selected_description})")
        print("正在嘗試下載最長可用數據...請稍候...")

        try:
            ticker = yf.Ticker(TICKER_SYMBOL)
            data = ticker.history(period="max", interval=interval_key, auto_adjust=True)

            if not data.empty:
                fetched_data_df = data # Store fetched data

                print("\n✅ 資料已成功抓取並準備就緒！")
                print(f"共獲取 {len(data)} 筆數據。")
                try:
                    min_time_str = data.index.min().strftime('%Y-%m-%d %H:%M:%S %Z') if data.index.tz is not None else data.index.min().strftime('%Y-%m-%d %H:%M:%S')
                    max_time_str = data.index.max().strftime('%Y-%m-%d %H:%M:%S %Z') if data.index.tz is not None else data.index.max().strftime('%Y-%m-%d %H:%M:%S')
                    print(f"數據時間範圍從: {min_time_str}")
                    print(f"數據時間範圍到: {max_time_str}")
                except Exception as e_time:
                    print(f"格式化時間戳時出錯: {e_time}")

                print("\n數據預覽 (開頭 3 筆):")
                display(data.head(3))
                print("\n數據預覽 (結尾 3 筆):")
                display(data.tail(3))

                print(f"\n✓ 資料已準備好。請點擊下方的按鈕選擇下載格式。")
                download_csv_button.disabled = False
                download_txt_button.disabled = False
                download_buttons_container.layout.visibility = 'visible'
            else:
                print("\n❌ 未能獲取任何數據。")
                print("可能原因：Yahoo Finance 對於此週期沒有可用數據，或網路問題。")

        except Exception as e:
            print(f"\n❗❗ 抓取數據時發生嚴重錯誤: {e}")
            import traceback
            print(traceback.format_exc())
        finally:
            fetch_data_button.disabled = False

def on_download_csv_button_clicked(b):
    global fetched_data_df, fetched_interval_key_for_filename
    with output_area:
        if fetched_data_df is not None and fetched_interval_key_for_filename is not None:
            filename = f"TWII_{fetched_interval_key_for_filename}_max_data.csv"
            print(f"\n準備下載 CSV 檔案: {filename} ...")
            try:
                fetched_data_df.to_csv(filename, index=True) # Include index for time series
                files.download(filename)
                print(f"✓ {filename} 的下載請求已發送。請檢查您的瀏覽器。")
            except Exception as e:
                print(f"\n❗ 儲存或下載 CSV 時發生錯誤: {e}")
        else:
            print("\n❗ 沒有已準備好的資料可供下載。請先成功點擊 '抓取資料'。")

def on_download_txt_button_clicked(b):
    global fetched_data_df, fetched_interval_key_for_filename
    with output_area:
        if fetched_data_df is not None and fetched_interval_key_for_filename is not None:
            filename = f"TWII_{fetched_interval_key_for_filename}_max_data.txt"
            print(f"\n準備下載 TXT 檔案: {filename} ...")
            print("(TXT 檔案將包含表格的純文字表示)")
            try:
                # Convert DataFrame to a string representation
                data_string = fetched_data_df.to_string(index=True) # Include index
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(data_string)
                files.download(filename)
                print(f"✓ {filename} 的下載請求已發送。請檢查您的瀏覽器。")
            except Exception as e:
                print(f"\n❗ 儲存或下載 TXT 時發生錯誤: {e}")
        else:
            print("\n❗ 沒有已準備好的資料可供下載。請先成功點擊 '抓取資料'。")

# Link button actions to their handler functions
fetch_data_button.on_click(on_fetch_data_button_clicked)
download_csv_button.on_click(on_download_csv_button_clicked)
download_txt_button.on_click(on_download_txt_button_clicked)

# Step 6: Arrange UI elements and display them
ui_layout = VBox([
    title_label,
    info_label,
    HBox([interval_label, interval_dropdown], layout=Layout(align_items='center', margin='0 0 10px 0')),
    fetch_data_button,
    download_buttons_container, # This HBox contains the two download buttons
    widgets.HTML("<hr style='margin-top: 15px; margin-bottom: 5px;'><b>處理狀態與結果:</b>"),
    output_area
])

# Display the UI
print("程式介面已準備就緒。請在下方選擇並操作。")
display(ui_layout)

# 步驟 1: 自動檢查並安裝必要的套件
import subprocess
import sys
import importlib

def install_and_import(package):
    try:
        importlib.import_module(package)
        print(f"套件 {package} 已安裝。")
    except ImportError:
        print(f"套件 {package} 未找到，正在嘗試安裝...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", package])
            print(f"套件 {package} 安裝成功。")
            # 為了讓 Colab 在同一次執行中能找到剛安裝的套件，有時需要特別處理
            # 但通常情況下，下次 import 就會成功。
            # 這裡我們繼續執行，如果 import 仍然失敗，使用者可能需要重新執行一次儲存格。
        except subprocess.CalledProcessError as e:
            print(f"套件 {package} 安裝失敗: {e}")
            print(f"請嘗試手動在一個新的儲存格執行: !pip install {package}")
            raise # 拋出異常，阻止後續執行，因為套件是必要的

# 檢查並安裝 FinMind 和 ipywidgets
try:
    install_and_import('FinMind')
    install_and_import('ipywidgets')
except Exception as e:
    print(f"初始化套件時發生問題，請檢查錯誤訊息並可能需要重新執行儲存格。錯誤: {e}")
    # 如果希望在安裝失敗時完全停止，可以在這裡 sys.exit() 或不執行後續的 display(ui)

# 步驟 2: 匯入必要的函式庫 (在確認安裝後)
import pandas as pd
from FinMind.data import DataLoader
from google.colab import userdata, files
import ipywidgets as widgets
from IPython.display import display, clear_output
import datetime

# 步驟 3: 從 Colab Secrets 取得 API Key 並初始化 FinMind DataLoader
api_key = None
api = None
initialization_error_message = ""

try:
    api_key = userdata.get('API_KEY_FINMIND')
    if api_key:
        api = DataLoader()
        api.login_by_token(api_token=api_key)
    else:
        # This case should ideally not happen if userdata.get raises SecretNotFoundError
        initialization_error_message = "錯誤：API Key ('API_KEY_FINMIND') 為空或未正確獲取。"
except userdata.SecretNotFoundError:
    initialization_error_message = "錯誤：找不到名為 'API_KEY_FINMIND' 的 Colab Secret。請先在 Colab 的密鑰管理員中設定它。"
except Exception as e:
    initialization_error_message = f"讀取 API Key 或初始化 FinMind 時發生錯誤: {e}"

# --- 全域變數，用於在回呼函式之間共享資料 ---
shared_data = {
    'df': pd.DataFrame(),
    'options_id': '',
    'start_date': '',
    'end_date': ''
}

# --- UI 元件定義 ---
title = widgets.HTML("<h2>台灣選擇權歷史每日資料下載工具 (FinMind API)</h2>")
description = widgets.HTML("<p>輸入選擇權代號及日期範圍，然後點擊「抓取資料」。資料成功載入後即可下載。</p>")

options_id_input = widgets.Text(
    value='TXO',
    placeholder='例如: TXO (臺指選擇權)',
    description='選擇權代號:',
    disabled=False,
    style={'description_width': 'initial'}
)
start_date_picker = widgets.DatePicker(
    description='開始日期:',
    disabled=False,
    value=datetime.date.today() - datetime.timedelta(days=30)
)
end_date_picker = widgets.DatePicker(
    description='結束日期:',
    disabled=False,
    value=datetime.date.today()
)

fetch_button = widgets.Button(
    description="抓取資料",
    button_style='info',
    tooltip='點擊以開始抓取選擇權資料',
    icon='download'
)
download_csv_button = widgets.Button(
    description="下載 CSV 檔案",
    button_style='success',
    tooltip='下載抓取到的資料為 CSV 檔案',
    icon='file-csv',
    disabled=True
)
download_txt_button = widgets.Button(
    description="下載 TXT 檔案",
    button_style='success',
    tooltip='下載抓取到的資料為 TXT 檔案',
    icon='file-alt',
    disabled=True
)

output_area = widgets.Output()

# --- 事件處理函式 ---
def on_fetch_button_clicked(b):
    global shared_data
    with output_area:
        clear_output(wait=True)
        print("處理中，請稍候...")
        fetch_button.disabled = True
        download_csv_button.disabled = True
        download_txt_button.disabled = True

        if not api:
            print(f"錯誤：FinMind API 未成功初始化。{initialization_error_message}")
            fetch_button.disabled = False
            return

        options_id_val = options_id_input.value
        start_date_val = start_date_picker.value.strftime('%Y-%m-%d') if start_date_picker.value else ''
        end_date_val = end_date_picker.value.strftime('%Y-%m-%d') if end_date_picker.value else ''

        if not all([options_id_val, start_date_val, end_date_val]):
            print("錯誤：選擇權代號、開始日期和結束日期皆不可為空。")
            fetch_button.disabled = False
            return

        try:
            print(f"正在從 FinMind 抓取 {options_id_val} 從 {start_date_val} 至 {end_date_val} 的資料...")
            df = api.taiwan_options_daily(
                options_id=options_id_val,
                start_date=start_date_val,
                end_date=end_date_val
            )

            if df.empty:
                print("查詢成功，但找不到符合條件的資料，或者 API 在此範圍內未提供資料。")
                shared_data['df'] = pd.DataFrame()
            else:
                shared_data['df'] = df
                shared_data['options_id'] = options_id_val
                shared_data['start_date'] = start_date_val
                shared_data['end_date'] = end_date_val
                print(f"\n資料已準備好！共 {len(df)} 筆。")
                print("資料預覽 (前5筆):")
                display(df.head())
                download_csv_button.disabled = False
                download_txt_button.disabled = False
        except Exception as e:
            print(f"抓取資料時發生錯誤: {e}")
            print("請檢查輸入的代號、日期範圍是否正確，或 API Key/網路連線狀態。")
            shared_data['df'] = pd.DataFrame()
        finally:
            fetch_button.disabled = False

def on_download_csv_button_clicked(b):
    global shared_data
    with output_area:
        if shared_data['df'].empty:
            print("沒有資料可供下載。")
            return
        filename = f"OPTIONS_{shared_data['options_id']}_{shared_data['start_date']}_to_{shared_data['end_date']}.csv"
        try:
            shared_data['df'].to_csv(filename, index=False, encoding='utf-8-sig')
            files.download(filename)
            print(f"CSV 檔案 '{filename}' 下載請求已發送。")
        except Exception as e:
            print(f"下載 CSV 檔案時發生錯誤: {e}")

def on_download_txt_button_clicked(b):
    global shared_data
    with output_area:
        if shared_data['df'].empty:
            print("沒有資料可供下載。")
            return
        filename = f"OPTIONS_{shared_data['options_id']}_{shared_data['start_date']}_to_{shared_data['end_date']}.txt"
        try:
            content = shared_data['df'].to_string(index=True)
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(content)
            files.download(filename)
            print(f"TXT 檔案 '{filename}' 下載請求已發送。")
        except Exception as e:
            print(f"下載 TXT 檔案時發生錯誤: {e}")

fetch_button.on_click(on_fetch_button_clicked)
download_csv_button.on_click(on_download_csv_button_clicked)
download_txt_button.on_click(on_download_txt_button_clicked)

# --- UI 佈局與顯示 ---
inputs_box = widgets.VBox([
    options_id_input,
    widgets.HBox([start_date_picker, end_date_picker])
])
buttons_box = widgets.HBox([
    fetch_button,
    download_csv_button,
    download_txt_button
], layout=widgets.Layout(margin='10px 0 0 0'))

ui = widgets.VBox([
    title,
    description,
    inputs_box,
    buttons_box,
    output_area
])

# 只有在 API Key 成功讀取並初始化 FinMind 後才顯示完整 UI
if not initialization_error_message and api: # 檢查初始化錯誤訊息是否為空且 api 物件存在
    display(ui)
else:
    with output_area:
        clear_output(wait=True)
        print("互動工具因初始化問題無法載入。請檢查以下訊息：")
        if initialization_error_message:
            print(initialization_error_message)
        else: # 如果 initialization_error_message 為空但 api 仍為 None (理論上不太可能發生在此邏輯)
            print("FinMind API 未知初始化錯誤。")
    display(output_area)


