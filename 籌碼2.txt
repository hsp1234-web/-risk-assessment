!pip install yfinance pandas matplotlib -q


# -*- coding: utf-8 -*-
# 在 Google Colab 中第一次執行時，取消下一行的註解來安裝必要的函式庫
# !pip install yfinance pandas matplotlib -q

# 匯入所需函式庫
import yfinance as yf         # 用於獲取股票和選擇權數據
import pandas as pd           # 用於數據處理 (DataFrame)
import numpy as np            # 用於數值計算 (例如 NaN, infinity)
import matplotlib.pyplot as plt # 用於繪圖
import matplotlib.ticker as mticker # 用於格式化圖表軸標籤
from datetime import datetime, timedelta # 用於處理日期和時間
from matplotlib.lines import Line2D      # 用於創建自訂圖例線條
import matplotlib.patches as mpatches    # 用於創建自訂圖例色塊
import traceback                # 用於打印詳細的錯誤追蹤信息

# --- 輔助函數：查找最接近的日期 ---
def find_closest_date(target_date, date_list_str):
    """
    在日期字串列表中找到最接近目標日期的日期字串。

    Args:
        target_date (datetime): 目標日期。
        date_list_str (list): 包含 'YYYY-MM-DD' 格式日期字串的列表。

    Returns:
        str or None: 列表中最接近的日期字串，如果列表為空或出錯則返回 None。
    """
    try:
        # 將字串列表轉換為 datetime 物件列表
        available_dates = [datetime.strptime(d_str, '%Y-%m-%d') for d_str in date_list_str]
        # 計算每個可用日期與目標日期的時間差
        time_diffs = [abs(d - target_date) for d in available_dates]
        if not time_diffs: # 如果列表為空
            return None
        # 找到最小時間差的索引
        min_diff_idx = np.argmin(time_diffs)
        # 返回對應的原始日期字串
        return date_list_str[min_diff_idx]
    except Exception as e:
        print(f"查找最近日期時出錯: {e}") # 打印錯誤信息
        return None

# --- 繪圖函數 (堆疊風格 + 新顏色) ---
def plot_option_distribution_stacked_style(
    near_data, week_data, month_data,
    current_price,
    near_exp, week_exp, month_exp,
    ticker_symbol):
    """
    繪製選擇權 OI 和 Volume 的垂直分佈圖 (Y軸為履約價) - 堆疊風格 + 新顏色。
    (包含數據有效性檢查)

    Args:
        near_data (dict or None): {'calls': DataFrame, 'puts': DataFrame} for nearest expiry.
        week_data (dict or None): {'calls': DataFrame, 'puts': DataFrame} for +1 week expiry.
        month_data (dict or None): {'calls': DataFrame, 'puts': DataFrame} for +1 month expiry.
        current_price (float or None): 目前股價。
        near_exp (str or None): Nearest expiration date string.
        week_exp (str or None): +1 week expiration date string.
        month_exp (str or None): +1 month expiration date string.
        ticker_symbol (str): 股票代號。
    """
    # --- 初始檢查 ---
    if current_price is None or np.isnan(current_price):
        print("\n警告：目前股價無效或無法獲取，跳過繪製圖表。")
        return
    if not isinstance(near_data, dict) or 'calls' not in near_data or 'puts' not in near_data:
         print("\n錯誤：最近到期日數據結構無效，無法繪製圖表。")
         return
    if near_data['calls'].empty and near_data['puts'].empty:
         print("\n提示：最近到期日無有效選擇權數據，無法繪製圖表。")
         return

    print("\n開始準備繪圖數據...")

    # --- 數據準備 ---
    # 設定繪圖的履約價範圍 (股價上下 30%)
    min_strike_disp = current_price * 0.70
    max_strike_disp = current_price * 1.30
    all_strikes_set = set() # 用於收集所有在範圍內的履約價

    def prepare_data_stacked(data, suffix, min_s, max_s):
        """輔助函數：準備用於堆疊圖的數據"""
        # 檢查輸入數據是否有效
        if not isinstance(data, dict) or 'calls' not in data or 'puts' not in data:
             return None, None
        calls_df = data['calls']
        puts_df = data['puts']
        if not isinstance(calls_df, pd.DataFrame) or not isinstance(puts_df, pd.DataFrame):
             return None, None

        # 篩選履約價為數值且在範圍內的數據
        calls_f = calls_df[pd.to_numeric(calls_df['strike'], errors='coerce').notna()].copy()
        puts_f = puts_df[pd.to_numeric(puts_df['strike'], errors='coerce').notna()].copy()
        calls_f['strike'] = pd.to_numeric(calls_f['strike'])
        puts_f['strike'] = pd.to_numeric(puts_f['strike'])
        calls_f = calls_f[calls_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()
        puts_f = puts_f[puts_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()

        # 確保所需欄位存在且為數值，填充缺失值
        for col in ['openInterest', 'volume']:
             if col not in calls_f.columns: calls_f[col] = 0
             if col not in puts_f.columns: puts_f[col] = 0
             calls_f[col] = pd.to_numeric(calls_f[col], errors='coerce').fillna(0)
             puts_f[col] = pd.to_numeric(puts_f[col], errors='coerce').fillna(0)

        # 收集履約價
        all_strikes_set.update(calls_f['strike'].tolist())
        all_strikes_set.update(puts_f['strike'].tolist())

        if calls_f.empty and puts_f.empty:
            return None, None

        # 準備 Call 數據 (欄位加上後綴)
        calls_f = calls_f.set_index('strike').add_suffix(f'_call{suffix}')

        # 準備 Put 數據 (同時準備正值和負值版本)
        puts_f_pos = puts_f.set_index('strike').add_suffix(f'_put_pos{suffix}') # 正值用於 barh 的 width
        puts_f_neg = puts_f.copy().set_index('strike')
        puts_f_neg['openInterest'] = -puts_f_neg['openInterest'] # 負值用於 barh 的 left
        puts_f_neg['volume'] = -puts_f_neg['volume']
        puts_f_neg = puts_f_neg.add_suffix(f'_put_neg{suffix}')
        puts_combined = puts_f_pos.join(puts_f_neg) # 合併正負 Put 數據

        return calls_f, puts_combined

    # 安全地準備各到期日數據
    try:
        calls_near, puts_near = prepare_data_stacked(near_data, '_near', min_strike_disp, max_strike_disp)
        calls_week, puts_week = prepare_data_stacked(week_data, '_week', min_strike_disp, max_strike_disp)
        calls_month, puts_month = prepare_data_stacked(month_data, '_month', min_strike_disp, max_strike_disp)
    except Exception as e_prep:
        print(f"\n錯誤：準備繪圖數據時出錯: {e_prep}")
        traceback.print_exc()
        return

    # 如果處理後沒有任何履約價，則不繪圖
    if not all_strikes_set:
         print(f"\n提示：在繪圖範圍 ${min_strike_disp:.2f} 到 ${max_strike_disp:.2f} 內無任何選擇權數據。")
         return

    # 創建包含所有履約價的 DataFrame
    plot_idx = pd.Index(sorted(list(all_strikes_set)), name='strike')
    plot_df = pd.DataFrame(index=plot_idx)

    # 安全地合併各期數據
    try:
        if calls_near is not None: plot_df = plot_df.join(calls_near)
        if puts_near is not None: plot_df = plot_df.join(puts_near)
        if calls_week is not None: plot_df = plot_df.join(calls_week)
        if puts_week is not None: plot_df = plot_df.join(puts_week)
        if calls_month is not None: plot_df = plot_df.join(calls_month)
        if puts_month is not None: plot_df = plot_df.join(puts_month)
        plot_df = plot_df.fillna(0) # 填充 NaN 為 0
        plot_df['strike'] = plot_df.index # 將索引加回為欄位
    except Exception as e_join:
         print(f"\n錯誤：合併繪圖數據時出錯: {e_join}")
         traceback.print_exc()
         return

    # 如果最終 DataFrame 為空，則不繪圖
    if plot_df.empty:
        print("\n提示：處理後的繪圖數據為空，無法繪製圖表。")
        return

    # --- 開始繪圖 ---
    try:
        print("開始繪製圖表...")
        fig, ax = plt.subplots(1, 2, figsize=(18, 14), sharey=True) # 創建畫布和子圖 (共享Y軸)
        fig.suptitle(f'{ticker_symbol} 選擇權分佈 - 堆疊風格 ({datetime.now().strftime("%Y-%m-%d")})', fontsize=16) # 圖表總標題

        # 計算 Bar 的高度
        strike_diff = np.diff(plot_df['strike'])
        min_strike_diff = np.min(strike_diff) if len(strike_diff) > 0 else 1.0
        bar_height = max(min_strike_diff * 0.7, 0.1) # 確保高度為正

        # 共用的 Bar 繪圖參數
        plot_args = {'height': bar_height, 'align': 'center', 'edgecolor': 'black', 'linewidth': 0.6}

        # --- 繪製 Open Interest 圖 ---
        ax_oi = ax[0] # 左側子圖
        # 最近到期 - 亮紅色 ('red')
        oi_call_near = plot_df.get(f'openInterest_call_near', 0)
        oi_put_near_neg = plot_df.get(f'openInterest_put_neg_near', 0)
        oi_put_near_pos = plot_df.get(f'openInterest_put_pos_near', 0)
        ax_oi.barh(plot_df['strike'], oi_call_near, color='red', left=0, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_near_pos, color='red', left=oi_put_near_neg, **plot_args)

        # 週到期 - 淡藍色 ('lightblue')
        oi_call_week = plot_df.get(f'openInterest_call_week', 0)
        oi_put_week_neg = plot_df.get(f'openInterest_put_neg_week', 0)
        oi_put_week_pos = plot_df.get(f'openInterest_put_pos_week', 0)
        ax_oi.barh(plot_df['strike'], oi_call_week, color='lightblue', left=oi_call_near, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_week_pos, color='lightblue', left=oi_put_near_neg + oi_put_week_neg, **plot_args)

        # 月到期 - 深紫色 ('purple')
        oi_call_month = plot_df.get(f'openInterest_call_month', 0)
        oi_put_month_neg = plot_df.get(f'openInterest_put_neg_month', 0)
        oi_put_month_pos = plot_df.get(f'openInterest_put_pos_month', 0)
        ax_oi.barh(plot_df['strike'], oi_call_month, color='purple', left=oi_call_near + oi_call_week, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_month_pos, color='purple', left=oi_put_near_neg + oi_put_week_neg + oi_put_month_neg, **plot_args)


        # --- 繪製 Volume 圖 ---
        ax_vol = ax[1] # 右側子圖
        # 最近到期 - 亮紅色 ('red')
        vol_call_near = plot_df.get(f'volume_call_near', 0)
        vol_put_near_neg = plot_df.get(f'volume_put_neg_near', 0)
        vol_put_near_pos = plot_df.get(f'volume_put_pos_near', 0)
        ax_vol.barh(plot_df['strike'], vol_call_near, color='red', left=0, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_near_pos, color='red', left=vol_put_near_neg, **plot_args)

        # 週到期 - 淡藍色 ('lightblue')
        vol_call_week = plot_df.get(f'volume_call_week', 0)
        vol_put_week_neg = plot_df.get(f'volume_put_neg_week', 0)
        vol_put_week_pos = plot_df.get(f'volume_put_pos_week', 0)
        ax_vol.barh(plot_df['strike'], vol_call_week, color='lightblue', left=vol_call_near, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_week_pos, color='lightblue', left=vol_put_near_neg + vol_put_week_neg, **plot_args)

        # 月到期 - 深紫色 ('purple')
        vol_call_month = plot_df.get(f'volume_call_month', 0)
        vol_put_month_neg = plot_df.get(f'volume_put_neg_month', 0)
        vol_put_month_pos = plot_df.get(f'volume_put_pos_month', 0)
        ax_vol.barh(plot_df['strike'], vol_call_month, color='purple', left=vol_call_near + vol_call_week, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_month_pos, color='purple', left=vol_put_near_neg + vol_put_week_neg + vol_put_month_neg, **plot_args)


        # --- 圖表格式化與增強 ---
        valid_strikes = plot_df['strike'].unique() # 獲取實際繪製的履約價
        for ax_curr in ax: # 循環處理兩個子圖
            # 繪製目前股價水平線
            ax_curr.axhline(current_price, color='k', linestyle='--', lw=1.5)

            # 繪製價內/價外背景區域
            y_min, y_max = ax_curr.get_ylim() # 獲取Y軸範圍
            ax_curr.axhspan(current_price, y_max, facecolor='red', alpha=0.08, zorder=0) # 價內 Put 區域 (淺紅)
            ax_curr.axhspan(y_min, current_price, facecolor='green', alpha=0.08, zorder=0)# 價內 Call 區域 (淺綠)

            # 設定網格線、軸刻度、標籤格式
            ax_curr.grid(axis='x', linestyle=':', alpha=0.6) # X軸網格線
            ax_curr.yaxis.set_ticks(valid_strikes)      # 設定Y軸刻度為履約價
            ax_curr.tick_params(axis='y', labelsize=9)  # Y軸標籤字體大小
            ax_curr.tick_params(axis='x', labelsize=9)  # X軸標籤字體大小
            ax_curr.xaxis.set_major_formatter(mticker.FuncFormatter(lambda x, p: f'{abs(x):,.0f}')) # X軸顯示絕對值且帶千分位

            # 設定X軸範圍，使其對稱
            current_xlim = ax_curr.get_xlim()
            max_abs_val = max(abs(current_xlim[0]), abs(current_xlim[1]), 1) # 找到最大絕對值 (至少為1)
            ax_curr.set_xlim(-max_abs_val*1.1, max_abs_val*1.1) # 設定對稱範圍並增加少許邊距

        # 設定子圖標籤和標題
        ax[0].set_xlabel('未平倉量 (Open Interest) (Puts <- | -> Calls)')
        ax[0].set_ylabel('履約價 (Strike Price)')
        ax[0].set_title('未平倉量分佈 (按到期日堆疊)')
        ax[1].set_xlabel('成交量 (Volume) (Puts <- | -> Calls)')
        ax[1].set_title('成交量分佈 (按到期日堆疊)')


        # --- 創建自訂圖例 ---
        legend_elements = [
            Line2D([0], [0], color='k', linestyle='--', label=f'目前價: ${current_price:.2f}' if current_price else '目前價: N/A'),
            # 使用色塊 (Patch) 代表堆疊的顏色
            mpatches.Patch(color='red', label=f'最近 ({near_exp})' if near_exp else '最近'),
        ]
        # 只有當週/月數據存在時才加入圖例
        if week_exp and week_data: legend_elements.append(mpatches.Patch(color='lightblue', label=f'+1週 ({week_exp})'))
        if month_exp and month_data: legend_elements.append(mpatches.Patch(color='purple', label=f'+1月 ({month_exp})'))
        # 加入價內/價外區域圖例
        legend_elements.append(mpatches.Patch(color='green', alpha=0.1, label='價內 Call 區'))
        legend_elements.append(mpatches.Patch(color='red', alpha=0.1, label='價內 Put 區'))

        # 在圖表下方顯示圖例
        fig.legend(handles=legend_elements, loc='lower center', ncol=3, bbox_to_anchor=(0.5, -0.03), fontsize=10)

        # 調整佈局防止重疊，並顯示圖表
        plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # 調整主體佈局區域
        plt.subplots_adjust(bottom=0.12) # 增加底部空間給圖例
        plt.show() # 顯示圖表
        print("圖表繪製完成。")

    except Exception as e_plot:
        print(f"\n錯誤：繪製圖表時發生錯誤: {e_plot}")
        traceback.print_exc() # 打印詳細繪圖錯誤

# --- 主分析函數 ---
def analyze_option_chain(ticker_symbol):
    """
    分析指定美股代號的選擇權鏈數據 (多到期日), 使用堆疊圖表 + 新顏色 + 強化錯誤處理。
    """
    print(f"--- 開始分析 {ticker_symbol} 選擇權籌碼 ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")
    # 初始化變數
    current_price = None
    near_data, week_data, month_data = None, None, None
    near_exp, week_exp, month_exp = None, None, None
    default_empty_data = {'calls': pd.DataFrame(), 'puts': pd.DataFrame()} # 標準空數據結構

    try:
        # 創建 Ticker 物件
        ticker = yf.Ticker(ticker_symbol)

        # --- 獲取股價 ---
        print("正在獲取股價...")
        try:
            # 優先使用 download 獲取最近兩天數據，可能更可靠
            hist = ticker.download(period='2d', progress=False, timeout=10) # progress=False 避免打印進度, timeout 防止卡住
            if not hist.empty:
                current_price = hist['Close'].iloc[-1] # 取最後一個收盤價
            # 如果 download 失敗或結果無效，嘗試 fast_info
            if current_price is None or np.isnan(current_price):
                print("  歷史數據收盤價無效，嘗試 fast_info...")
                fast_info = ticker.fast_info
                current_price = fast_info.get('lastPrice') # 使用 .get 避免 KeyError
        except Exception as e_price_hist:
            print(f"  獲取歷史股價失敗 ({e_price_hist})，嘗試 fast_info...")
            try:
                 fast_info = ticker.fast_info
                 current_price = fast_info.get('lastPrice')
            except Exception as e_price_fast:
                 print(f"  獲取 fast_info 股價也失敗: {e_price_fast}")

        # 最終檢查股價是否有效
        if current_price is not None and not np.isnan(current_price):
            print(f"  成功獲取股價: ${current_price:.2f}")
        else:
            # 即使沒有股價，也打印警告並繼續（繪圖函數會處理）
            print(f"\n警告：無法獲取有效的目前股價 ({current_price})，部分分析（如價內外判斷）可能不準確。")


        # --- 獲取選擇權到期日 ---
        print("正在獲取選擇權到期日...")
        try:
            expirations = ticker.options
            if not expirations: # 如果沒有任何到期日
                print(f"\n錯誤：找不到 {ticker_symbol} 的任何選擇權到期日。請檢查代號或確認該股票有選擇權。")
                return # 停止執行
        except Exception as e_exp:
            print(f"\n錯誤：獲取到期日列表時出錯: {e_exp}")
            traceback.print_exc()
            return # 停止執行

        # --- 獲取各到期日選擇權鏈數據 ---

        # 1. 最近到期日 (通常是 Index 0，可能是 0DTE)
        near_exp = expirations[0]
        print(f"\n處理最近到期日 (Near): {near_exp}")
        try:
            near_chain = ticker.option_chain(near_exp)
            # 安全地獲取 calls 和 puts，如果不存在則返回空 DataFrame
            near_data = {
                'calls': getattr(near_chain, 'calls', pd.DataFrame()),
                'puts': getattr(near_chain, 'puts', pd.DataFrame())
            }
            if near_data['calls'].empty and near_data['puts'].empty:
                print(f"  注意：{near_exp} 無 Calls 或 Puts 數據。")
            else:
                 print(f"  成功獲取 {near_exp} 數據。")
        except Exception as e:
            print(f"  錯誤：無法獲取 {near_exp} 數據: {e}")
            near_data = default_empty_data.copy() # 保證結構存在

        # 2. +1 週到期日
        week_exp = None # 先初始化
        try:
            near_date = datetime.strptime(near_exp, '%Y-%m-%d')
            target_week_date = near_date + timedelta(weeks=1) # 計算目標日期
            future_expirations = [d for d in expirations if d > near_exp] # 找出未來的所有到期日
            if future_expirations:
                week_exp_candidate = find_closest_date(target_week_date, future_expirations) # 查找最接近的
                # 檢查找到的日期是否有效且與最近日期不同
                if week_exp_candidate and week_exp_candidate != near_exp and abs(datetime.strptime(week_exp_candidate, '%Y-%m-%d') - target_week_date) < timedelta(days=10):
                    week_exp = week_exp_candidate # 確認選用此日期
                    print(f"處理 +1 週到期日 (Week): {week_exp}")
                    try:
                        week_chain = ticker.option_chain(week_exp)
                        week_data = {
                             'calls': getattr(week_chain, 'calls', pd.DataFrame()),
                             'puts': getattr(week_chain, 'puts', pd.DataFrame())
                         }
                        if week_data['calls'].empty and week_data['puts'].empty:
                           print(f"  注意：{week_exp} 無 Calls 或 Puts 數據。")
                        else:
                           print(f"  成功獲取 {week_exp} 數據。")
                    except Exception as e:
                        print(f"  錯誤：無法獲取 {week_exp} 數據: {e}")
                        week_data = None # 獲取失敗設為 None
            if not week_exp: print("未找到或選定合適的 +1 週到期日。")
        except Exception as e_wk:
            print(f"查找/處理 +1 週到期日時出錯: {e_wk}")
            week_data = None

        # 3. +1 月到期日
        month_exp = None # 先初始化
        try:
            if near_exp: # 必須有最近日期才能計算目標月日期
                near_date = datetime.strptime(near_exp, '%Y-%m-%d')
                target_month_date = near_date + timedelta(days=30) # 計算目標日期 (約一個月)
                # 查找的起始日期：如果有週到期，從週到期之後開始；否則從最近到期之後開始
                start_search_date = datetime.strptime(week_exp, '%Y-%m-%d') if week_exp else near_date
                future_expirations_month = [d for d in expirations if d > start_search_date.strftime('%Y-%m-%d')]
                if future_expirations_month:
                    month_exp_candidate = find_closest_date(target_month_date, future_expirations_month)
                    # 檢查找到的日期是否有效且與其他日期不同
                    if month_exp_candidate and month_exp_candidate != week_exp and month_exp_candidate != near_exp and abs(datetime.strptime(month_exp_candidate, '%Y-%m-%d') - target_month_date) < timedelta(days=20):
                        month_exp = month_exp_candidate # 確認選用此日期
                        print(f"處理 +1 月到期日 (Month): {month_exp}")
                        try:
                            month_chain = ticker.option_chain(month_exp)
                            month_data = {
                                 'calls': getattr(month_chain, 'calls', pd.DataFrame()),
                                 'puts': getattr(month_chain, 'puts', pd.DataFrame())
                             }
                            if month_data['calls'].empty and month_data['puts'].empty:
                               print(f"  注意：{month_exp} 無 Calls 或 Puts 數據。")
                            else:
                                print(f"  成功獲取 {month_exp} 數據。")
                        except Exception as e:
                            print(f"  錯誤：無法獲取 {month_exp} 數據: {e}")
                            month_data = None # 獲取失敗設為 None
                if not month_exp: print("未找到或選定合適的 +1 月到期日。")
        except Exception as e_mo:
            print(f"查找/處理 +1 月到期日時出錯: {e_mo}")
            month_data = None

        # --- 文字分析 (僅基於最近到期日數據) ---
        print("\n--- 最近到期日 ({}) 數據分析 ---".format(near_exp if near_exp else 'N/A'))
        # 執行分析的前提：near_data 存在，且 calls 和 puts 是 DataFrame，且至少有一個不為空
        if near_data and isinstance(near_data.get('calls'), pd.DataFrame) and isinstance(near_data.get('puts'), pd.DataFrame) and not (near_data['calls'].empty and near_data['puts'].empty):
            calls_near_df = near_data['calls']
            puts_near_df = near_data['puts']

            # --- 潛在壓力/支撐分析 ---
            print("\n潛在壓力區 (基於最近到期 Call OI):")
            # 需要有有效的股價才能判斷價外
            if current_price is not None and not np.isnan(current_price):
                if not calls_near_df.empty and 'openInterest' in calls_near_df.columns:
                    # 確保 strike 和 OI 為數值
                    calls_near_df['strike'] = pd.to_numeric(calls_near_df['strike'], errors='coerce')
                    calls_near_df['openInterest'] = pd.to_numeric(calls_near_df['openInterest'], errors='coerce')
                    calls_near_df.dropna(subset=['strike', 'openInterest'], inplace=True) # 移除無效行

                    otm_calls = calls_near_df[calls_near_df['strike'] > current_price].copy() # 篩選價外 (>股價)
                    if not otm_calls.empty:
                        # 按 OI 降序排列，取前 5 大，再按 strike 升序顯示
                        top_otm_calls = otm_calls.nlargest(5, 'openInterest', keep='first').sort_values('strike')
                        # 確保 volume 存在且為數值
                        if 'volume' not in top_otm_calls.columns: top_otm_calls['volume'] = 0
                        top_otm_calls['volume'] = pd.to_numeric(top_otm_calls['volume'], errors='coerce').fillna(0)
                        print(top_otm_calls[['strike', 'openInterest', 'volume']].to_string(index=False))
                    else: print("  目前股價上方無價外 Call 或無 OI 數據。")
                else: print("  無 Call 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Call (缺少有效股價)。")

            # 打印當前價格分隔線
            if current_price is not None and not np.isnan(current_price):
                 print(f"\n>>>>> 目前股價: ${current_price:.2f} <<<<<")

            print("\n潛在支撐區 (基於最近到期 Put OI):")
            if current_price is not None and not np.isnan(current_price):
                if not puts_near_df.empty and 'openInterest' in puts_near_df.columns:
                    # 確保 strike 和 OI 為數值
                    puts_near_df['strike'] = pd.to_numeric(puts_near_df['strike'], errors='coerce')
                    puts_near_df['openInterest'] = pd.to_numeric(puts_near_df['openInterest'], errors='coerce')
                    puts_near_df.dropna(subset=['strike', 'openInterest'], inplace=True)

                    otm_puts = puts_near_df[puts_near_df['strike'] < current_price].copy() # 篩選價外 (<股價)
                    if not otm_puts.empty:
                        # 按 OI 降序排列，取前 5 大，再按 strike 降序顯示
                        top_otm_puts = otm_puts.nlargest(5, 'openInterest', keep='first').sort_values('strike', ascending=False)
                        # 確保 volume 存在且為數值
                        if 'volume' not in top_otm_puts.columns: top_otm_puts['volume'] = 0
                        top_otm_puts['volume'] = pd.to_numeric(top_otm_puts['volume'], errors='coerce').fillna(0)
                        print(top_otm_puts[['strike', 'openInterest', 'volume']].to_string(index=False))
                    else: print("  目前股價下方無價外 Put 或無 OI 數據。")
                else: print("  無 Put 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Put (缺少有效股價)。")


            # --- 計算 PCR (Put/Call Ratio) ---
            print("\n市場情緒指標 (基於最近到期日):")
            # 檢查 Volume 欄位是否存在
            if 'volume' in calls_near_df.columns and 'volume' in puts_near_df.columns:
                total_call_volume = pd.to_numeric(calls_near_df['volume'], errors='coerce').fillna(0).sum()
                total_put_volume = pd.to_numeric(puts_near_df['volume'], errors='coerce').fillna(0).sum()
                # 避免除以零
                pcr_volume = total_put_volume / total_call_volume if total_call_volume > 0 else np.inf
                print(f"  成交量 PCR: {pcr_volume:.2f}" if pcr_volume != np.inf else "成交量 PCR: N/A (Call Volume=0)")
            else: print("  成交量 PCR: N/A (缺少 Volume 數據)")

            # 檢查 Open Interest 欄位是否存在
            if 'openInterest' in calls_near_df.columns and 'openInterest' in puts_near_df.columns:
                total_call_oi = pd.to_numeric(calls_near_df['openInterest'], errors='coerce').fillna(0).sum()
                total_put_oi = pd.to_numeric(puts_near_df['openInterest'], errors='coerce').fillna(0).sum()
                # 避免除以零
                pcr_oi = total_put_oi / total_call_oi if total_call_oi > 0 else np.inf
                print(f"  未平倉量 PCR: {pcr_oi:.2f}" if pcr_oi != np.inf else "未平倉量 PCR: N/A (Call OI=0)")

                # --- 計算最大痛點 (Max Pain) ---
                # 需要 strike 和 openInterest 欄位
                if 'strike' in calls_near_df.columns and 'strike' in puts_near_df.columns:
                     try:
                         # 準備計算數據，確保為數值
                         calls_calc = calls_near_df[['strike', 'openInterest']].copy()
                         puts_calc = puts_near_df[['strike', 'openInterest']].copy()
                         calls_calc['strike'] = pd.to_numeric(calls_calc['strike'], errors='coerce')
                         calls_calc['openInterest'] = pd.to_numeric(calls_calc['openInterest'], errors='coerce')
                         puts_calc['strike'] = pd.to_numeric(puts_calc['strike'], errors='coerce')
                         puts_calc['openInterest'] = pd.to_numeric(puts_calc['openInterest'], errors='coerce')
                         calls_calc.dropna(inplace=True)
                         puts_calc.dropna(inplace=True)

                         if not calls_calc.empty and not puts_calc.empty:
                            # 獲取所有唯一履約價
                            strikes = pd.concat([calls_calc['strike'], puts_calc['strike']]).unique()
                            strikes.sort()
                            # 創建 OI 查找字典/Series
                            call_oi_map = calls_calc.set_index('strike')['openInterest']
                            put_oi_map = puts_calc.set_index('strike')['openInterest']
                            min_loss = float('inf') # 初始化最小損失
                            max_pain_strike = -1    # 初始化最大痛點履約價

                            # 遍歷每個履約價，計算假設以此價格結算的總損失
                            for potential_expiry_price in strikes:
                                total_loss_at_strike = 0
                                # 計算 Call 買方內在價值總和 (賣方損失)
                                for call_strike, oi in call_oi_map.items():
                                     if potential_expiry_price > call_strike:
                                         total_loss_at_strike += (potential_expiry_price - call_strike) * oi
                                # 計算 Put 買方內在價值總和 (賣方損失)
                                for put_strike, oi in put_oi_map.items():
                                     if potential_expiry_price < put_strike:
                                         total_loss_at_strike += (put_strike - potential_expiry_price) * oi

                                # 如果當前履約價的總損失更小，則更新最大痛點
                                if total_loss_at_strike < min_loss:
                                    min_loss = total_loss_at_strike
                                    max_pain_strike = potential_expiry_price

                            if max_pain_strike != -1:
                                print(f"  預估最大痛點履約價: ${max_pain_strike:.2f}")
                            else: print("  無法計算最大痛點 (無有效履約價)。")
                         else: print("  無法計算最大痛點 (無有效數據)。")
                     except Exception as e_maxpain:
                         print(f"  計算最大痛點時出錯: {e_maxpain}")
                else: print("  最大痛點: N/A (缺少 Strike 數據)")
            else: print("  未平倉量 PCR / 最大痛點: N/A (缺少 OpenInterest 數據)")
        else:
             print("  缺少有效的最近到期日數據，無法進行文字分析。")


        # --- 繪製圖表 ---
        print("\n--- 繪製選擇權分佈圖 ---")
        # 只有在 near_data 至少有基本結構時才嘗試繪圖
        if near_data is not None:
            # 調用更新後的繪圖函數
            plot_option_distribution_stacked_style(
                near_data, week_data, month_data,
                current_price, # 傳遞股價，繪圖函數會處理 None 的情況
                near_exp, week_exp, month_exp,
                ticker_symbol
            )
        else:
            print("  無最近到期日數據結構，無法繪製圖表。")


    except Exception as e: # 捕獲 analyze_option_chain 中的其他未預期錯誤
        print(f"\n處理 {ticker_symbol} 時發生未預期的嚴重錯誤: {e}")
        traceback.print_exc() # 打印詳細錯誤信息

    finally: # 無論成功或失敗，都打印結束信息
        print(f"\n--- 分析結束 ---")


# --- 主程式執行區塊 ---
if __name__ == "__main__":
    # --- 環境檢查與安裝 (Colab) ---
    try:
        import google.colab
        # 如果在 Colab 環境，則安靜模式安裝/更新函式庫
        print("偵測到 Google Colab 環境，執行 pip install...")
        !pip install yfinance pandas matplotlib -q
    except ImportError:
        # 如果不在 Colab，提示用戶確保已安裝
        print("非 Colab 環境，請確保已安裝 yfinance, pandas, matplotlib")

    # --- 匯入必要的函式庫 (再次確認) ---
    from datetime import datetime, timedelta
    import matplotlib.patches as mpatches
    from matplotlib.lines import Line2D
    import traceback # 確保 traceback 已匯入

    # --- 獲取使用者輸入 ---
    print("\n========================================")
    # 提示使用者輸入股票代號，並移除可能的空格
    input_ticker = input("請輸入欲分析的美股代號 (例如: AAPL, SPY, TSLA): ").strip().upper()
    print("========================================")


    # --- 執行分析 ---
    # 檢查使用者是否有輸入
    if input_ticker:
        # 使用者輸入的代號來執行分析函數
        analyze_option_chain(input_ticker)
    else:
        # 如果未輸入，則提示錯誤
        print("錯誤：未輸入股票代號，無法進行分析。")


# -*- coding: utf-8 -*-
# 在 Google Colab 中第一次執行時，取消下一行的註解來安裝必要的函式庫
# !pip install yfinance pandas matplotlib -q

# 匯入所需函式庫
import yfinance as yf         # 用於獲取股票和選擇權數據
import pandas as pd           # 用於數據處理 (DataFrame)
import numpy as np            # 用於數值計算 (例如 NaN, infinity)
import matplotlib.pyplot as plt # 用於繪圖
import matplotlib.ticker as mticker # 用於格式化圖表軸標籤
# *** 新增匯入 MaxNLocator ***
from matplotlib.ticker import MaxNLocator
from datetime import datetime, timedelta # 用於處理日期和時間
from matplotlib.lines import Line2D      # 用於創建自訂圖例線條
import matplotlib.patches as mpatches    # 用於創建自訂圖例色塊
import traceback                # 用於打印詳細的錯誤追蹤信息

# --- 輔助函數：查找最接近的日期 (保持不變) ---
def find_closest_date(target_date, date_list_str):
    """
    在日期字串列表中找到最接近目標日期的日期字串。

    Args:
        target_date (datetime): 目標日期。
        date_list_str (list): 包含 'YYYY-MM-DD' 格式日期字串的列表。

    Returns:
        str or None: 列表中最接近的日期字串，如果列表為空或出錯則返回 None。
    """
    try:
        available_dates = [datetime.strptime(d_str, '%Y-%m-%d') for d_str in date_list_str]
        time_diffs = [abs(d - target_date) for d in available_dates]
        if not time_diffs:
            return None
        min_diff_idx = np.argmin(time_diffs)
        return date_list_str[min_diff_idx]
    except Exception as e:
        # print(f"查找最近日期時出錯: {e}") # 可選的調試打印
        return None

# --- 繪圖函數 (堆疊風格 + 紅綠/淡藍/深紫 + Y軸優化) ---
def plot_option_distribution_stacked_style(
    near_data, week_data, month_data,
    current_price,
    near_exp, week_exp, month_exp,
    ticker_symbol):
    """
    繪製選擇權 OI 和 Volume 的垂直分佈圖 (Y軸為履約價) - 堆疊風格 + 新顏色 + Y軸優化。
    """
    # --- 初始檢查 (保持不變) ---
    if current_price is None or np.isnan(current_price):
        print("\n警告：目前股價無效或無法獲取，跳過繪製圖表。")
        return
    if not isinstance(near_data, dict) or 'calls' not in near_data or 'puts' not in near_data:
         print("\n錯誤：最近到期日數據結構無效，無法繪製圖表。")
         return
    if near_data['calls'].empty and near_data['puts'].empty:
         print("\n提示：最近到期日無有效選擇權數據，無法繪製圖表。")
         return

    print("\n開始準備繪圖數據...")

    # --- 數據準備 (保持不變) ---
    min_strike_disp = current_price * 0.70
    max_strike_disp = current_price * 1.30
    all_strikes_set = set()

    def prepare_data_stacked(data, suffix, min_s, max_s):
        if not isinstance(data, dict) or 'calls' not in data or 'puts' not in data:
             return None, None
        calls_df = data['calls']
        puts_df = data['puts']
        if not isinstance(calls_df, pd.DataFrame) or not isinstance(puts_df, pd.DataFrame):
             return None, None

        calls_f = calls_df[pd.to_numeric(calls_df['strike'], errors='coerce').notna()].copy()
        puts_f = puts_df[pd.to_numeric(puts_df['strike'], errors='coerce').notna()].copy()
        calls_f['strike'] = pd.to_numeric(calls_f['strike'])
        puts_f['strike'] = pd.to_numeric(puts_f['strike'])
        calls_f = calls_f[calls_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()
        puts_f = puts_f[puts_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()

        for col in ['openInterest', 'volume']:
             if col not in calls_f.columns: calls_f[col] = 0
             if col not in puts_f.columns: puts_f[col] = 0
             calls_f[col] = pd.to_numeric(calls_f[col], errors='coerce').fillna(0)
             puts_f[col] = pd.to_numeric(puts_f[col], errors='coerce').fillna(0)

        all_strikes_set.update(calls_f['strike'].tolist())
        all_strikes_set.update(puts_f['strike'].tolist())

        if calls_f.empty and puts_f.empty:
            return None, None

        calls_f = calls_f.set_index('strike').add_suffix(f'_call{suffix}')
        puts_f_pos = puts_f.set_index('strike').add_suffix(f'_put_pos{suffix}')
        puts_f_neg = puts_f.copy().set_index('strike')
        puts_f_neg['openInterest'] = -puts_f_neg['openInterest']
        puts_f_neg['volume'] = -puts_f_neg['volume']
        puts_f_neg = puts_f_neg.add_suffix(f'_put_neg{suffix}')
        puts_combined = puts_f_pos.join(puts_f_neg)
        return calls_f, puts_combined

    try:
        calls_near, puts_near = prepare_data_stacked(near_data, '_near', min_strike_disp, max_strike_disp)
        calls_week, puts_week = prepare_data_stacked(week_data, '_week', min_strike_disp, max_strike_disp)
        calls_month, puts_month = prepare_data_stacked(month_data, '_month', min_strike_disp, max_strike_disp)
    except Exception as e_prep:
        print(f"\n錯誤：準備繪圖數據時出錯: {e_prep}")
        traceback.print_exc()
        return

    if not all_strikes_set:
         print(f"\n提示：在繪圖範圍 ${min_strike_disp:.2f} 到 ${max_strike_disp:.2f} 內無任何選擇權數據。")
         return

    plot_idx = pd.Index(sorted(list(all_strikes_set)), name='strike')
    plot_df = pd.DataFrame(index=plot_idx)

    try:
        if calls_near is not None: plot_df = plot_df.join(calls_near)
        if puts_near is not None: plot_df = plot_df.join(puts_near)
        if calls_week is not None: plot_df = plot_df.join(calls_week)
        if puts_week is not None: plot_df = plot_df.join(puts_week)
        if calls_month is not None: plot_df = plot_df.join(calls_month)
        if puts_month is not None: plot_df = plot_df.join(puts_month)
        plot_df = plot_df.fillna(0)
        plot_df['strike'] = plot_df.index
    except Exception as e_join:
         print(f"\n錯誤：合併繪圖數據時出錯: {e_join}")
         traceback.print_exc()
         return

    if plot_df.empty:
        print("\n提示：處理後的繪圖數據為空，無法繪製圖表。")
        return

    # --- 開始繪圖 ---
    try:
        print("開始繪製圖表...")
        fig, ax = plt.subplots(1, 2, figsize=(18, 14), sharey=True)
        fig.suptitle(f'{ticker_symbol} 選擇權分佈 - 堆疊風格 ({datetime.now().strftime("%Y-%m-%d")})', fontsize=16)

        strike_diff = np.diff(plot_df['strike'])
        min_strike_diff = np.min(strike_diff) if len(strike_diff) > 0 else 1.0
        bar_height = max(min_strike_diff * 0.7, 0.1)

        plot_args = {'height': bar_height, 'align': 'center', 'edgecolor': 'black', 'linewidth': 0.6}

        # --- OI Plot ---
        ax_oi = ax[0]
        # 最近到期 - Call 紅色 / Put 綠色
        oi_call_near = plot_df.get('openInterest_call_near', 0)
        oi_put_near_neg = plot_df.get('openInterest_put_neg_near', 0)
        oi_put_near_pos = plot_df.get('openInterest_put_pos_near', 0)
        ax_oi.barh(plot_df['strike'], oi_call_near, color='red', left=0, **plot_args) # Near Call = Red
        ax_oi.barh(plot_df['strike'], oi_put_near_pos, color='green', left=oi_put_near_neg, **plot_args) # *** Near Put = Green ***

        # 週到期 - 淡藍色 ('lightblue')
        oi_call_week = plot_df.get('openInterest_call_week', 0)
        oi_put_week_neg = plot_df.get('openInterest_put_neg_week', 0)
        oi_put_week_pos = plot_df.get('openInterest_put_pos_week', 0)
        ax_oi.barh(plot_df['strike'], oi_call_week, color='lightblue', left=oi_call_near, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_week_pos, color='lightblue', left=oi_put_near_neg + oi_put_week_neg, **plot_args)

        # 月到期 - 深紫色 ('purple')
        oi_call_month = plot_df.get('openInterest_call_month', 0)
        oi_put_month_neg = plot_df.get('openInterest_put_neg_month', 0)
        oi_put_month_pos = plot_df.get('openInterest_put_pos_month', 0)
        ax_oi.barh(plot_df['strike'], oi_call_month, color='purple', left=oi_call_near + oi_call_week, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_month_pos, color='purple', left=oi_put_near_neg + oi_put_week_neg + oi_put_month_neg, **plot_args)

        # --- Volume Plot ---
        ax_vol = ax[1]
        # 最近到期 - Call 紅色 / Put 綠色
        vol_call_near = plot_df.get('volume_call_near', 0)
        vol_put_near_neg = plot_df.get('volume_put_neg_near', 0)
        vol_put_near_pos = plot_df.get('volume_put_pos_near', 0)
        ax_vol.barh(plot_df['strike'], vol_call_near, color='red', left=0, **plot_args) # Near Call = Red
        ax_vol.barh(plot_df['strike'], vol_put_near_pos, color='green', left=vol_put_near_neg, **plot_args) # *** Near Put = Green ***

        # 週到期 - 淡藍色 ('lightblue')
        vol_call_week = plot_df.get('volume_call_week', 0)
        vol_put_week_neg = plot_df.get('volume_put_neg_week', 0)
        vol_put_week_pos = plot_df.get('volume_put_pos_week', 0)
        ax_vol.barh(plot_df['strike'], vol_call_week, color='lightblue', left=vol_call_near, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_week_pos, color='lightblue', left=vol_put_near_neg + vol_put_week_neg, **plot_args)

        # 月到期 - 深紫色 ('purple')
        vol_call_month = plot_df.get('volume_call_month', 0)
        vol_put_month_neg = plot_df.get('volume_put_neg_month', 0)
        vol_put_month_pos = plot_df.get('volume_put_pos_month', 0)
        ax_vol.barh(plot_df['strike'], vol_call_month, color='purple', left=vol_call_near + vol_call_week, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_month_pos, color='purple', left=vol_put_near_neg + vol_put_week_neg + vol_put_month_neg, **plot_args)

        # --- Enhancements & Formatting ---
        # valid_strikes = plot_df['strike'].unique() # 不再需要，使用 MaxNLocator
        for ax_curr in ax:
            ax_curr.axhline(current_price, color='k', linestyle='--', lw=1.5)

            y_min, y_max = ax_curr.get_ylim()
            ax_curr.axhspan(current_price, y_max, facecolor='red', alpha=0.08, zorder=0)
            ax_curr.axhspan(y_min, current_price, facecolor='green', alpha=0.08, zorder=0)

            ax_curr.grid(axis='x', linestyle=':', alpha=0.6)
            # *** 使用 MaxNLocator 控制 Y 軸刻度數量 ***
            ax_curr.yaxis.set_major_locator(MaxNLocator(nbins=25, integer=True)) # nbins=25 是建議值，可調整

            ax_curr.tick_params(axis='y', labelsize=8) # *** 稍微縮小 Y 軸字體 ***
            ax_curr.tick_params(axis='x', labelsize=9)
            ax_curr.xaxis.set_major_formatter(mticker.FuncFormatter(lambda x, p: f'{abs(x):,.0f}'))

            current_xlim = ax_curr.get_xlim()
            max_abs_val = max(abs(current_xlim[0]), abs(current_xlim[1]), 1)
            ax_curr.set_xlim(-max_abs_val*1.1, max_abs_val*1.1)

        ax[0].set_xlabel('未平倉量 (Open Interest) (Puts <- | -> Calls)')
        ax[0].set_ylabel('履約價 (Strike Price)')
        ax[0].set_title('未平倉量分佈 (按到期日堆疊)')
        ax[1].set_xlabel('成交量 (Volume) (Puts <- | -> Calls)')
        ax[1].set_title('成交量分佈 (按到期日堆疊)')


        # --- Custom Legend (Updated for NEW Colors) ---
        legend_elements = [
            Line2D([0], [0], color='k', linestyle='--', label=f'目前價: ${current_price:.2f}' if current_price else '目前價: N/A'),
            # *** 更新最近日期的圖例 ***
            mpatches.Patch(color='red', label=f'最近 Call ({near_exp})' if near_exp else '最近 Call'),
            mpatches.Patch(color='green', label=f'最近 Put ({near_exp})' if near_exp else '最近 Put'),
        ]
        if week_exp and week_data: legend_elements.append(mpatches.Patch(color='lightblue', label=f'+1週 ({week_exp})'))
        if month_exp and month_data: legend_elements.append(mpatches.Patch(color='purple', label=f'+1月 ({month_exp})'))
        legend_elements.append(mpatches.Patch(color='green', alpha=0.1, label='價內 Call 區'))
        legend_elements.append(mpatches.Patch(color='red', alpha=0.1, label='價內 Put 區'))

        fig.legend(handles=legend_elements, loc='lower center', ncol=3, bbox_to_anchor=(0.5, -0.03), fontsize=10)

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.subplots_adjust(bottom=0.12)
        plt.show()
        print("圖表繪製完成。")

    except Exception as e_plot:
        print(f"\n錯誤：繪製圖表時發生錯誤: {e_plot}")
        traceback.print_exc()

# --- 主分析函數 (保持不變，調用更新後的繪圖函數) ---
def analyze_option_chain(ticker_symbol):
    """
    分析指定美股代號的選擇權鏈數據 (多到期日), 使用堆疊圖表 + 新顏色 + Y軸優化 + 強化錯誤處理。
    """
    print(f"--- 開始分析 {ticker_symbol} 選擇權籌碼 ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")
    current_price = None
    near_data, week_data, month_data = None, None, None
    near_exp, week_exp, month_exp = None, None, None
    default_empty_data = {'calls': pd.DataFrame(), 'puts': pd.DataFrame()}

    try:
        ticker = yf.Ticker(ticker_symbol)

        print("正在獲取股價...")
        try:
            hist = ticker.download(period='2d', progress=False, timeout=10)
            if not hist.empty:
                current_price = hist['Close'].iloc[-1]
            if current_price is None or np.isnan(current_price):
                #print("  歷史數據收盤價無效，嘗試 fast_info...") #減少打印信息
                fast_info = ticker.fast_info
                current_price = fast_info.get('lastPrice')
        except Exception as e_price_hist:
            #print(f"  獲取歷史股價失敗 ({e_price_hist})，嘗試 fast_info...") #減少打印信息
            try:
                 fast_info = ticker.fast_info
                 current_price = fast_info.get('lastPrice')
            except Exception as e_price_fast:
                 print(f"  獲取 fast_info 股價也失敗: {e_price_fast}")

        if current_price is not None and not np.isnan(current_price):
            print(f"  成功獲取股價: ${current_price:.2f}")
        else:
            print(f"\n警告：無法獲取有效的目前股價 ({current_price})。")

        print("正在獲取選擇權到期日...")
        try:
            expirations = ticker.options
            if not expirations:
                print(f"\n錯誤：找不到 {ticker_symbol} 的任何選擇權到期日。")
                return
        except Exception as e_exp:
            print(f"\n錯誤：獲取到期日列表時出錯: {e_exp}")
            traceback.print_exc()
            return

        # --- Get Option Chains Safely ---
        near_exp = expirations[0]
        print(f"\n處理最近到期日 (Near): {near_exp}")
        try:
            near_chain = ticker.option_chain(near_exp)
            near_data = {
                'calls': getattr(near_chain, 'calls', pd.DataFrame()),
                'puts': getattr(near_chain, 'puts', pd.DataFrame())
            }
            if not (near_data['calls'].empty and near_data['puts'].empty):
                 print(f"  成功獲取 {near_exp} 數據。")
            # else: print(f"  注意：{near_exp} 無 Calls 或 Puts 數據。") #減少打印信息
        except Exception as e:
            print(f"  錯誤：無法獲取 {near_exp} 數據: {e}")
            near_data = default_empty_data.copy()

        # +1 Week Expiration
        week_exp = None
        try:
            near_date = datetime.strptime(near_exp, '%Y-%m-%d')
            target_week_date = near_date + timedelta(weeks=1)
            future_expirations = [d for d in expirations if d > near_exp]
            if future_expirations:
                week_exp_candidate = find_closest_date(target_week_date, future_expirations)
                if week_exp_candidate and week_exp_candidate != near_exp and abs(datetime.strptime(week_exp_candidate, '%Y-%m-%d') - target_week_date) < timedelta(days=10):
                    week_exp = week_exp_candidate
                    print(f"處理 +1 週到期日 (Week): {week_exp}")
                    try:
                        week_chain = ticker.option_chain(week_exp)
                        week_data = {
                             'calls': getattr(week_chain, 'calls', pd.DataFrame()),
                             'puts': getattr(week_chain, 'puts', pd.DataFrame())
                         }
                        if not (week_data['calls'].empty and week_data['puts'].empty):
                            print(f"  成功獲取 {week_exp} 數據。")
                        # else: print(f"  注意：{week_exp} 無 Calls 或 Puts 數據。") #減少打印信息
                    except Exception as e:
                        print(f"  錯誤：無法獲取 {week_exp} 數據: {e}")
                        week_data = None
            #if not week_exp: print("未找到或選定合適的 +1 週到期日。") #減少打印信息
        except Exception as e_wk:
            print(f"查找/處理 +1 週到期日時出錯: {e_wk}")
            week_data = None

        # +1 Month Expiration
        month_exp = None
        try:
            if near_exp:
                near_date = datetime.strptime(near_exp, '%Y-%m-%d')
                target_month_date = near_date + timedelta(days=30)
                start_search_date = datetime.strptime(week_exp, '%Y-%m-%d') if week_exp else near_date
                future_expirations_month = [d for d in expirations if d > start_search_date.strftime('%Y-%m-%d')]
                if future_expirations_month:
                    month_exp_candidate = find_closest_date(target_month_date, future_expirations_month)
                    if month_exp_candidate and month_exp_candidate != week_exp and month_exp_candidate != near_exp and abs(datetime.strptime(month_exp_candidate, '%Y-%m-%d') - target_month_date) < timedelta(days=20):
                        month_exp = month_exp_candidate
                        print(f"處理 +1 月到期日 (Month): {month_exp}")
                        try:
                            month_chain = ticker.option_chain(month_exp)
                            month_data = {
                                 'calls': getattr(month_chain, 'calls', pd.DataFrame()),
                                 'puts': getattr(month_chain, 'puts', pd.DataFrame())
                             }
                            if not (month_data['calls'].empty and month_data['puts'].empty):
                                print(f"  成功獲取 {month_exp} 數據。")
                            # else: print(f"  注意：{month_exp} 無 Calls 或 Puts 數據。") #減少打印信息
                        except Exception as e:
                            print(f"  錯誤：無法獲取 {month_exp} 數據: {e}")
                            month_data = None
                #if not month_exp: print("未找到或選定合適的 +1 月到期日。") #減少打印信息
        except Exception as e_mo:
            print(f"查找/處理 +1 月到期日時出錯: {e_mo}")
            month_data = None

        # --- 文字分析 (基於最近到期日數據) ---
        print("\n--- 最近到期日 ({}) 數據分析 ---".format(near_exp if near_exp else 'N/A'))
        if near_data and isinstance(near_data.get('calls'), pd.DataFrame) and isinstance(near_data.get('puts'), pd.DataFrame) and not (near_data['calls'].empty and near_data['puts'].empty):
            calls_near_df = near_data['calls']
            puts_near_df = near_data['puts']

            print("\n潛在壓力區 (基於最近到期 Call OI):")
            if current_price is not None and not np.isnan(current_price):
                if not calls_near_df.empty and 'openInterest' in calls_near_df.columns:
                    calls_near_df['strike'] = pd.to_numeric(calls_near_df['strike'], errors='coerce')
                    calls_near_df['openInterest'] = pd.to_numeric(calls_near_df['openInterest'], errors='coerce')
                    calls_near_df.dropna(subset=['strike', 'openInterest'], inplace=True)
                    otm_calls = calls_near_df[calls_near_df['strike'] > current_price].copy()
                    if not otm_calls.empty:
                        top_otm_calls = otm_calls.nlargest(5, 'openInterest', keep='first').sort_values('strike')
                        if 'volume' not in top_otm_calls.columns: top_otm_calls['volume'] = 0
                        top_otm_calls['volume'] = pd.to_numeric(top_otm_calls['volume'], errors='coerce').fillna(0)
                        print(top_otm_calls[['strike', 'openInterest', 'volume']].to_string(index=False))
                    else: print("  目前股價上方無價外 Call 或無 OI 數據。")
                else: print("  無 Call 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Call (缺少有效股價)。")

            if current_price is not None and not np.isnan(current_price):
                 print(f"\n>>>>> 目前股價: ${current_price:.2f} <<<<<")

            print("\n潛在支撐區 (基於最近到期 Put OI):")
            if current_price is not None and not np.isnan(current_price):
                if not puts_near_df.empty and 'openInterest' in puts_near_df.columns:
                     puts_near_df['strike'] = pd.to_numeric(puts_near_df['strike'], errors='coerce')
                     puts_near_df['openInterest'] = pd.to_numeric(puts_near_df['openInterest'], errors='coerce')
                     puts_near_df.dropna(subset=['strike', 'openInterest'], inplace=True)
                     otm_puts = puts_near_df[puts_near_df['strike'] < current_price].copy()
                     if not otm_puts.empty:
                         top_otm_puts = otm_puts.nlargest(5, 'openInterest', keep='first').sort_values('strike', ascending=False)
                         if 'volume' not in top_otm_puts.columns: top_otm_puts['volume'] = 0
                         top_otm_puts['volume'] = pd.to_numeric(top_otm_puts['volume'], errors='coerce').fillna(0)
                         print(top_otm_puts[['strike', 'openInterest', 'volume']].to_string(index=False))
                     else: print("  目前股價下方無價外 Put 或無 OI 數據。")
                else: print("  無 Put 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Put (缺少有效股價)。")

            print("\n市場情緒指標 (基於最近到期日):")
            if 'volume' in calls_near_df.columns and 'volume' in puts_near_df.columns:
                total_call_volume = pd.to_numeric(calls_near_df['volume'], errors='coerce').fillna(0).sum()
                total_put_volume = pd.to_numeric(puts_near_df['volume'], errors='coerce').fillna(0).sum()
                pcr_volume = total_put_volume / total_call_volume if total_call_volume > 0 else np.inf
                print(f"  成交量 PCR: {pcr_volume:.2f}" if pcr_volume != np.inf else "成交量 PCR: N/A")
            else: print("  成交量 PCR: N/A")

            if 'openInterest' in calls_near_df.columns and 'openInterest' in puts_near_df.columns:
                total_call_oi = pd.to_numeric(calls_near_df['openInterest'], errors='coerce').fillna(0).sum()
                total_put_oi = pd.to_numeric(puts_near_df['openInterest'], errors='coerce').fillna(0).sum()
                pcr_oi = total_put_oi / total_call_oi if total_call_oi > 0 else np.inf
                print(f"  未平倉量 PCR: {pcr_oi:.2f}" if pcr_oi != np.inf else "未平倉量 PCR: N/A")

                if 'strike' in calls_near_df.columns and 'strike' in puts_near_df.columns:
                     try:
                         calls_calc = calls_near_df[['strike', 'openInterest']].copy()
                         puts_calc = puts_near_df[['strike', 'openInterest']].copy()
                         calls_calc['strike'] = pd.to_numeric(calls_calc['strike'], errors='coerce')
                         calls_calc['openInterest'] = pd.to_numeric(calls_calc['openInterest'], errors='coerce')
                         puts_calc['strike'] = pd.to_numeric(puts_calc['strike'], errors='coerce')
                         puts_calc['openInterest'] = pd.to_numeric(puts_calc['openInterest'], errors='coerce')
                         calls_calc.dropna(inplace=True)
                         puts_calc.dropna(inplace=True)

                         if not calls_calc.empty and not puts_calc.empty:
                            strikes = pd.concat([calls_calc['strike'], puts_calc['strike']]).unique()
                            strikes.sort()
                            call_oi_map = calls_calc.set_index('strike')['openInterest']
                            put_oi_map = puts_calc.set_index('strike')['openInterest']
                            min_loss = float('inf')
                            max_pain_strike = -1
                            for strike_price in strikes:
                                total_loss_at_strike = 0
                                for call_strike, oi in call_oi_map.items():
                                     if strike_price > call_strike: total_loss_at_strike += (strike_price - call_strike) * oi
                                for put_strike, oi in put_oi_map.items():
                                     if strike_price < put_strike: total_loss_at_strike += (put_strike - strike_price) * oi
                                if total_loss_at_strike < min_loss:
                                    min_loss = total_loss_at_strike
                                    max_pain_strike = strike_price
                            if max_pain_strike != -1: print(f"  預估最大痛點: ${max_pain_strike:.2f}")
                            # else: print("  無法計算最大痛點。") #減少打印信息
                         # else: print("  無法計算最大痛點。") #減少打印信息
                     except Exception as e_maxpain:
                         print(f"  計算最大痛點時出錯: {e_maxpain}")
                # else: print("  最大痛點: N/A") #減少打印信息
            # else: print("  未平倉量 PCR / 最大痛點: N/A") #減少打印信息
        else:
             print("  缺少有效的最近到期日數據，無法進行文字分析。")

        print("\n--- 繪製選擇權分佈圖 ---")
        if near_data is not None:
            plot_option_distribution_stacked_style(
                near_data, week_data, month_data,
                current_price,
                near_exp, week_exp, month_exp,
                ticker_symbol
            )
        else:
            print("  無最近到期日數據結構，無法繪製圖表。")

    except Exception as e:
        print(f"\n處理 {ticker_symbol} 時發生未預期的嚴重錯誤: {e}")
        traceback.print_exc()

    finally:
        print(f"\n--- 分析結束 ---")


# --- 主程式執行區塊 ---
if __name__ == "__main__":
    try:
        import google.colab
        print("偵測到 Google Colab 環境，執行 pip install...")
        !pip install yfinance pandas matplotlib -q
    except ImportError:
        print("非 Colab 環境，請確保已安裝 yfinance, pandas, matplotlib")

    # --- 匯入必要的函式庫 ---
    from datetime import datetime, timedelta
    # *** 再次確認匯入 MaxNLocator ***
    from matplotlib.ticker import MaxNLocator
    import matplotlib.patches as mpatches
    from matplotlib.lines import Line2D
    import traceback

    # --- 獲取使用者輸入 ---
    print("\n========================================")
    input_ticker = input("請輸入欲分析的美股代號 (例如: AAPL, SPY, TSLA): ").strip().upper()
    print("========================================")

    # --- 執行分析 ---
    if input_ticker:
        analyze_option_chain(input_ticker)
    else:
        print("錯誤：未輸入股票代號，無法進行分析。")


# -*- coding: utf-8 -*- # 保留以防萬一有其他地方用到中文
# 在 Google Colab 中第一次執行時，取消下一行的註解來安裝必要的函式庫
# !pip install yfinance pandas matplotlib -q

# 匯入所需函式庫
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
from matplotlib.ticker import MaxNLocator # Y軸刻度優化
from datetime import datetime, timedelta
from matplotlib.lines import Line2D
import matplotlib.patches as mpatches
import traceback

# --- 輔助函數：查找最接近的日期 (保持不變) ---
def find_closest_date(target_date, date_list_str):
    try:
        available_dates = [datetime.strptime(d_str, '%Y-%m-%d') for d_str in date_list_str]
        time_diffs = [abs(d - target_date) for d in available_dates]
        if not time_diffs:
            return None
        min_diff_idx = np.argmin(time_diffs)
        return date_list_str[min_diff_idx]
    except Exception as e:
        return None

# --- 繪圖函數 (全英文標籤 + 顏色修正 + Y軸優化) ---
def plot_option_distribution_stacked_style(
    near_data, week_data, month_data,
    current_price,
    near_exp, week_exp, month_exp,
    ticker_symbol):
    """
    Plots option OI and Volume distribution (vertical, stacked style) with English labels.
    Colors: Near (Call=Red, Put=Green), +1wk (LightBlue), +1mo (Purple)
    """
    # --- Initial Checks ---
    if current_price is None or np.isnan(current_price):
        print("\nWarning: Current price is invalid or unavailable. Skipping chart.")
        return
    if not isinstance(near_data, dict) or 'calls' not in near_data or 'puts' not in near_data:
         print("\nError: Invalid data structure for near-term expiration. Cannot plot.")
         return
    if near_data['calls'].empty and near_data['puts'].empty:
         print("\nInfo: No valid option data for near-term expiration. Cannot plot.")
         return

    print("\nPreparing data for plotting...") # Keep console messages in Chinese for now

    # --- Data Preparation (Logic remains the same) ---
    min_strike_disp = current_price * 0.70
    max_strike_disp = current_price * 1.30
    all_strikes_set = set()

    def prepare_data_stacked(data, suffix, min_s, max_s):
        if not isinstance(data, dict) or 'calls' not in data or 'puts' not in data: return None, None
        calls_df = data['calls']
        puts_df = data['puts']
        if not isinstance(calls_df, pd.DataFrame) or not isinstance(puts_df, pd.DataFrame): return None, None

        calls_f = calls_df[pd.to_numeric(calls_df['strike'], errors='coerce').notna()].copy()
        puts_f = puts_df[pd.to_numeric(puts_df['strike'], errors='coerce').notna()].copy()
        calls_f['strike'] = pd.to_numeric(calls_f['strike'])
        puts_f['strike'] = pd.to_numeric(puts_f['strike'])
        calls_f = calls_f[calls_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()
        puts_f = puts_f[puts_f['strike'].between(min_s, max_s)][['strike', 'openInterest', 'volume']].copy()

        for col in ['openInterest', 'volume']:
             if col not in calls_f.columns: calls_f[col] = 0
             if col not in puts_f.columns: puts_f[col] = 0
             calls_f[col] = pd.to_numeric(calls_f[col], errors='coerce').fillna(0)
             puts_f[col] = pd.to_numeric(puts_f[col], errors='coerce').fillna(0)

        all_strikes_set.update(calls_f['strike'].tolist())
        all_strikes_set.update(puts_f['strike'].tolist())

        if calls_f.empty and puts_f.empty: return None, None

        calls_f = calls_f.set_index('strike').add_suffix(f'_call{suffix}')
        puts_f_pos = puts_f.set_index('strike').add_suffix(f'_put_pos{suffix}')
        puts_f_neg = puts_f.copy().set_index('strike')
        puts_f_neg['openInterest'] = -puts_f_neg['openInterest']
        puts_f_neg['volume'] = -puts_f_neg['volume']
        puts_f_neg = puts_f_neg.add_suffix(f'_put_neg{suffix}')
        puts_combined = puts_f_pos.join(puts_f_neg)
        return calls_f, puts_combined

    try:
        calls_near, puts_near = prepare_data_stacked(near_data, '_near', min_strike_disp, max_strike_disp)
        calls_week, puts_week = prepare_data_stacked(week_data, '_week', min_strike_disp, max_strike_disp)
        calls_month, puts_month = prepare_data_stacked(month_data, '_month', min_strike_disp, max_strike_disp)
    except Exception as e_prep:
        print(f"\nError preparing plot data: {e_prep}")
        traceback.print_exc()
        return

    if not all_strikes_set:
         print(f"\nInfo: No option data found within the plotting range (${min_strike_disp:.2f} to ${max_strike_disp:.2f}).")
         return

    plot_idx = pd.Index(sorted(list(all_strikes_set)), name='strike')
    plot_df = pd.DataFrame(index=plot_idx)

    try:
        if calls_near is not None: plot_df = plot_df.join(calls_near)
        if puts_near is not None: plot_df = plot_df.join(puts_near)
        if calls_week is not None: plot_df = plot_df.join(calls_week)
        if puts_week is not None: plot_df = plot_df.join(puts_week)
        if calls_month is not None: plot_df = plot_df.join(calls_month)
        if puts_month is not None: plot_df = plot_df.join(puts_month)
        plot_df = plot_df.fillna(0)
        plot_df['strike'] = plot_df.index
    except Exception as e_join:
         print(f"\nError merging plot data: {e_join}")
         traceback.print_exc()
         return

    if plot_df.empty:
        print("\nInfo: Plot data is empty after processing.")
        return

    # --- Plotting ---
    try:
        print("Generating plot...") # Keep console messages in Chinese
        fig, ax = plt.subplots(1, 2, figsize=(18, 14), sharey=True)
        # *** English Figure Title ***
        fig.suptitle(f'{ticker_symbol} Option Distribution - Stacked Style ({datetime.now().strftime("%Y-%m-%d")})', fontsize=16)

        strike_diff = np.diff(plot_df['strike'])
        min_strike_diff = np.min(strike_diff) if len(strike_diff) > 0 else 1.0
        bar_height = max(min_strike_diff * 0.7, 0.1)

        plot_args = {'height': bar_height, 'align': 'center', 'edgecolor': 'black', 'linewidth': 0.6}

        # --- OI Plot ---
        ax_oi = ax[0]
        # Near Expiry - Call=Red / Put=Green
        oi_call_near = plot_df.get('openInterest_call_near', 0)
        oi_put_near_neg = plot_df.get('openInterest_put_neg_near', 0)
        oi_put_near_pos = plot_df.get('openInterest_put_pos_near', 0)
        ax_oi.barh(plot_df['strike'], oi_call_near, color='red', left=0, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_near_pos, color='green', left=oi_put_near_neg, **plot_args)

        # Week Expiry - Light Blue
        oi_call_week = plot_df.get('openInterest_call_week', 0)
        oi_put_week_neg = plot_df.get('openInterest_put_neg_week', 0)
        oi_put_week_pos = plot_df.get('openInterest_put_pos_week', 0)
        ax_oi.barh(plot_df['strike'], oi_call_week, color='lightblue', left=oi_call_near, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_week_pos, color='lightblue', left=oi_put_near_neg + oi_put_week_neg, **plot_args)

        # Month Expiry - Deep Purple
        oi_call_month = plot_df.get('openInterest_call_month', 0)
        oi_put_month_neg = plot_df.get('openInterest_put_neg_month', 0)
        oi_put_month_pos = plot_df.get('openInterest_put_pos_month', 0)
        ax_oi.barh(plot_df['strike'], oi_call_month, color='purple', left=oi_call_near + oi_call_week, **plot_args)
        ax_oi.barh(plot_df['strike'], oi_put_month_pos, color='purple', left=oi_put_near_neg + oi_put_week_neg + oi_put_month_neg, **plot_args)

        # --- Volume Plot ---
        ax_vol = ax[1]
        # Near Expiry - Call=Red / Put=Green
        vol_call_near = plot_df.get('volume_call_near', 0)
        vol_put_near_neg = plot_df.get('volume_put_neg_near', 0)
        vol_put_near_pos = plot_df.get('volume_put_pos_near', 0)
        ax_vol.barh(plot_df['strike'], vol_call_near, color='red', left=0, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_near_pos, color='green', left=vol_put_near_neg, **plot_args)

        # Week Expiry - Light Blue
        vol_call_week = plot_df.get('volume_call_week', 0)
        vol_put_week_neg = plot_df.get('volume_put_neg_week', 0)
        vol_put_week_pos = plot_df.get('volume_put_pos_week', 0)
        ax_vol.barh(plot_df['strike'], vol_call_week, color='lightblue', left=vol_call_near, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_week_pos, color='lightblue', left=vol_put_near_neg + vol_put_week_neg, **plot_args)

        # Month Expiry - Deep Purple
        vol_call_month = plot_df.get('volume_call_month', 0)
        vol_put_month_neg = plot_df.get('volume_put_neg_month', 0)
        vol_put_month_pos = plot_df.get('volume_put_pos_month', 0)
        ax_vol.barh(plot_df['strike'], vol_call_month, color='purple', left=vol_call_near + vol_call_week, **plot_args)
        ax_vol.barh(plot_df['strike'], vol_put_month_pos, color='purple', left=vol_put_near_neg + vol_put_week_neg + vol_put_month_neg, **plot_args)


        # --- Enhancements & Formatting ---
        for ax_curr in ax:
            ax_curr.axhline(current_price, color='k', linestyle='--', lw=1.5)

            y_min, y_max = ax_curr.get_ylim()
            ax_curr.axhspan(current_price, y_max, facecolor='red', alpha=0.08, zorder=0)
            ax_curr.axhspan(y_min, current_price, facecolor='green', alpha=0.08, zorder=0)

            ax_curr.grid(axis='x', linestyle=':', alpha=0.6)
            ax_curr.yaxis.set_major_locator(MaxNLocator(nbins=25, integer=True)) # Auto ticks

            ax_curr.tick_params(axis='y', labelsize=8)
            ax_curr.tick_params(axis='x', labelsize=9)
            ax_curr.xaxis.set_major_formatter(mticker.FuncFormatter(lambda x, p: f'{abs(x):,.0f}'))

            current_xlim = ax_curr.get_xlim()
            max_abs_val = max(abs(current_xlim[0]), abs(current_xlim[1]), 1)
            ax_curr.set_xlim(-max_abs_val*1.1, max_abs_val*1.1)

        # *** English Axis Labels and Titles ***
        ax[0].set_xlabel('Open Interest (Puts <- | -> Calls)')
        ax[0].set_ylabel('Strike Price')
        ax[0].set_title('Open Interest (Stacked by Expiry)')
        ax[1].set_xlabel('Volume (Puts <- | -> Calls)')
        ax[1].set_title('Volume (Stacked by Expiry)')


        # --- Custom Legend (Updated with English) ---
        legend_elements = [
            Line2D([0], [0], color='k', linestyle='--', label=f'Current: ${current_price:.2f}' if current_price else 'Current: N/A'),
            mpatches.Patch(color='red', label=f'Near Call ({near_exp})' if near_exp else 'Near Call'),
            mpatches.Patch(color='green', label=f'Near Put ({near_exp})' if near_exp else 'Near Put'),
        ]
        # Add week/month legends only if data exists
        if week_exp and week_data: legend_elements.append(mpatches.Patch(color='lightblue', label=f'+1wk ({week_exp})'))
        if month_exp and month_data: legend_elements.append(mpatches.Patch(color='purple', label=f'+1mo ({month_exp})'))
        # Add ITM/OTM area legends
        legend_elements.append(mpatches.Patch(color='green', alpha=0.1, label='ITM Call Area'))
        legend_elements.append(mpatches.Patch(color='red', alpha=0.1, label='ITM Put Area'))

        fig.legend(handles=legend_elements, loc='lower center', ncol=3, bbox_to_anchor=(0.5, -0.03), fontsize=10)

        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.subplots_adjust(bottom=0.12)
        plt.show()
        print("圖表繪製完成。") # Keep console messages in Chinese

    except Exception as e_plot:
        print(f"\nError during plotting: {e_plot}")
        traceback.print_exc()

# --- 主分析函數 (保持不變) ---
def analyze_option_chain(ticker_symbol):
    """
    分析指定美股代號的選擇權鏈數據 (多到期日), 使用堆疊圖表 + 新顏色 + Y軸優化 + 強化錯誤處理。
    """
    print(f"--- 開始分析 {ticker_symbol} 選擇權籌碼 ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")
    current_price = None
    near_data, week_data, month_data = None, None, None
    near_exp, week_exp, month_exp = None, None, None
    default_empty_data = {'calls': pd.DataFrame(), 'puts': pd.DataFrame()}

    try:
        ticker = yf.Ticker(ticker_symbol)

        print("正在獲取股價...")
        try:
            hist = ticker.download(period='2d', progress=False, timeout=10)
            if not hist.empty:
                current_price = hist['Close'].iloc[-1]
            if current_price is None or np.isnan(current_price):
                fast_info = ticker.fast_info
                current_price = fast_info.get('lastPrice')
        except Exception as e_price_hist:
            try:
                 fast_info = ticker.fast_info
                 current_price = fast_info.get('lastPrice')
            except Exception as e_price_fast:
                 print(f"  獲取 fast_info 股價也失敗: {e_price_fast}")

        if current_price is not None and not np.isnan(current_price):
            print(f"  成功獲取股價: ${current_price:.2f}")
        else:
            print(f"\n警告：無法獲取有效的目前股價 ({current_price})。")

        print("正在獲取選擇權到期日...")
        try:
            expirations = ticker.options
            if not expirations:
                print(f"\n錯誤：找不到 {ticker_symbol} 的任何選擇權到期日。")
                return
        except Exception as e_exp:
            print(f"\n錯誤：獲取到期日列表時出錯: {e_exp}")
            traceback.print_exc()
            return

        # --- Get Option Chains Safely ---
        near_exp = expirations[0]
        print(f"\n處理最近到期日 (Near): {near_exp}")
        try:
            near_chain = ticker.option_chain(near_exp)
            near_data = {
                'calls': getattr(near_chain, 'calls', pd.DataFrame()),
                'puts': getattr(near_chain, 'puts', pd.DataFrame())
            }
            if not (near_data['calls'].empty and near_data['puts'].empty):
                 print(f"  成功獲取 {near_exp} 數據。")
        except Exception as e:
            print(f"  錯誤：無法獲取 {near_exp} 數據: {e}")
            near_data = default_empty_data.copy()

        # +1 Week Expiration
        week_exp = None
        try:
            near_date = datetime.strptime(near_exp, '%Y-%m-%d')
            target_week_date = near_date + timedelta(weeks=1)
            future_expirations = [d for d in expirations if d > near_exp]
            if future_expirations:
                week_exp_candidate = find_closest_date(target_week_date, future_expirations)
                if week_exp_candidate and week_exp_candidate != near_exp and abs(datetime.strptime(week_exp_candidate, '%Y-%m-%d') - target_week_date) < timedelta(days=10):
                    week_exp = week_exp_candidate
                    print(f"處理 +1 週到期日 (Week): {week_exp}")
                    try:
                        week_chain = ticker.option_chain(week_exp)
                        week_data = {
                             'calls': getattr(week_chain, 'calls', pd.DataFrame()),
                             'puts': getattr(week_chain, 'puts', pd.DataFrame())
                         }
                        if not (week_data['calls'].empty and week_data['puts'].empty):
                            print(f"  成功獲取 {week_exp} 數據。")
                    except Exception as e:
                        print(f"  錯誤：無法獲取 {week_exp} 數據: {e}")
                        week_data = None
        except Exception as e_wk:
            print(f"查找/處理 +1 週到期日時出錯: {e_wk}")
            week_data = None

        # +1 Month Expiration
        month_exp = None
        try:
            if near_exp:
                near_date = datetime.strptime(near_exp, '%Y-%m-%d')
                target_month_date = near_date + timedelta(days=30)
                start_search_date = datetime.strptime(week_exp, '%Y-%m-%d') if week_exp else near_date
                future_expirations_month = [d for d in expirations if d > start_search_date.strftime('%Y-%m-%d')]
                if future_expirations_month:
                    month_exp_candidate = find_closest_date(target_month_date, future_expirations_month)
                    if month_exp_candidate and month_exp_candidate != week_exp and month_exp_candidate != near_exp and abs(datetime.strptime(month_exp_candidate, '%Y-%m-%d') - target_month_date) < timedelta(days=20):
                        month_exp = month_exp_candidate
                        print(f"處理 +1 月到期日 (Month): {month_exp}")
                        try:
                            month_chain = ticker.option_chain(month_exp)
                            month_data = {
                                 'calls': getattr(month_chain, 'calls', pd.DataFrame()),
                                 'puts': getattr(month_chain, 'puts', pd.DataFrame())
                             }
                            if not (month_data['calls'].empty and month_data['puts'].empty):
                                print(f"  成功獲取 {month_exp} 數據。")
                        except Exception as e:
                            print(f"  錯誤：無法獲取 {month_exp} 數據: {e}")
                            month_data = None
        except Exception as e_mo:
            print(f"查找/處理 +1 月到期日時出錯: {e_mo}")
            month_data = None

        # --- 文字分析 (基於最近到期日數據) ---
        print("\n--- 最近到期日 ({}) 數據分析 ---".format(near_exp if near_exp else 'N/A')) # Keep console messages in Chinese
        if near_data and isinstance(near_data.get('calls'), pd.DataFrame) and isinstance(near_data.get('puts'), pd.DataFrame) and not (near_data['calls'].empty and near_data['puts'].empty):
            calls_near_df = near_data['calls']
            puts_near_df = near_data['puts']

            print("\n潛在壓力區 (基於最近到期 Call OI):")
            if current_price is not None and not np.isnan(current_price):
                if not calls_near_df.empty and 'openInterest' in calls_near_df.columns:
                    calls_near_df['strike'] = pd.to_numeric(calls_near_df['strike'], errors='coerce')
                    calls_near_df['openInterest'] = pd.to_numeric(calls_near_df['openInterest'], errors='coerce')
                    calls_near_df.dropna(subset=['strike', 'openInterest'], inplace=True)
                    otm_calls = calls_near_df[calls_near_df['strike'] > current_price].copy()
                    if not otm_calls.empty:
                        top_otm_calls = otm_calls.nlargest(5, 'openInterest', keep='first').sort_values('strike')
                        if 'volume' not in top_otm_calls.columns: top_otm_calls['volume'] = 0
                        top_otm_calls['volume'] = pd.to_numeric(top_otm_calls['volume'], errors='coerce').fillna(0)
                        print(top_otm_calls[['strike', 'openInterest', 'volume']].to_string(index=False))
                    else: print("  目前股價上方無價外 Call 或無 OI 數據。")
                else: print("  無 Call 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Call (缺少有效股價)。")

            if current_price is not None and not np.isnan(current_price):
                 print(f"\n>>>>> 目前股價: ${current_price:.2f} <<<<<")

            print("\n潛在支撐區 (基於最近到期 Put OI):")
            if current_price is not None and not np.isnan(current_price):
                if not puts_near_df.empty and 'openInterest' in puts_near_df.columns:
                     puts_near_df['strike'] = pd.to_numeric(puts_near_df['strike'], errors='coerce')
                     puts_near_df['openInterest'] = pd.to_numeric(puts_near_df['openInterest'], errors='coerce')
                     puts_near_df.dropna(subset=['strike', 'openInterest'], inplace=True)
                     otm_puts = puts_near_df[puts_near_df['strike'] < current_price].copy()
                     if not otm_puts.empty:
                         top_otm_puts = otm_puts.nlargest(5, 'openInterest', keep='first').sort_values('strike', ascending=False)
                         if 'volume' not in top_otm_puts.columns: top_otm_puts['volume'] = 0
                         top_otm_puts['volume'] = pd.to_numeric(top_otm_puts['volume'], errors='coerce').fillna(0)
                         print(top_otm_puts[['strike', 'openInterest', 'volume']].to_string(index=False))
                     else: print("  目前股價下方無價外 Put 或無 OI 數據。")
                else: print("  無 Put 數據或缺少 openInterest 欄位。")
            else: print("  無法判斷價外 Put (缺少有效股價)。")

            print("\n市場情緒指標 (基於最近到期日):")
            if 'volume' in calls_near_df.columns and 'volume' in puts_near_df.columns:
                total_call_volume = pd.to_numeric(calls_near_df['volume'], errors='coerce').fillna(0).sum()
                total_put_volume = pd.to_numeric(puts_near_df['volume'], errors='coerce').fillna(0).sum()
                pcr_volume = total_put_volume / total_call_volume if total_call_volume > 0 else np.inf
                print(f"  成交量 PCR: {pcr_volume:.2f}" if pcr_volume != np.inf else "成交量 PCR: N/A")
            else: print("  成交量 PCR: N/A")

            if 'openInterest' in calls_near_df.columns and 'openInterest' in puts_near_df.columns:
                total_call_oi = pd.to_numeric(calls_near_df['openInterest'], errors='coerce').fillna(0).sum()
                total_put_oi = pd.to_numeric(puts_near_df['openInterest'], errors='coerce').fillna(0).sum()
                pcr_oi = total_put_oi / total_call_oi if total_call_oi > 0 else np.inf
                print(f"  未平倉量 PCR: {pcr_oi:.2f}" if pcr_oi != np.inf else "未平倉量 PCR: N/A")

                if 'strike' in calls_near_df.columns and 'strike' in puts_near_df.columns:
                     try:
                         calls_calc = calls_near_df[['strike', 'openInterest']].copy()
                         puts_calc = puts_near_df[['strike', 'openInterest']].copy()
                         calls_calc['strike'] = pd.to_numeric(calls_calc['strike'], errors='coerce')
                         calls_calc['openInterest'] = pd.to_numeric(calls_calc['openInterest'], errors='coerce')
                         puts_calc['strike'] = pd.to_numeric(puts_calc['strike'], errors='coerce')
                         puts_calc['openInterest'] = pd.to_numeric(puts_calc['openInterest'], errors='coerce')
                         calls_calc.dropna(inplace=True)
                         puts_calc.dropna(inplace=True)

                         if not calls_calc.empty and not puts_calc.empty:
                            strikes = pd.concat([calls_calc['strike'], puts_calc['strike']]).unique()
                            strikes.sort()
                            call_oi_map = calls_calc.set_index('strike')['openInterest']
                            put_oi_map = puts_calc.set_index('strike')['openInterest']
                            min_loss = float('inf')
                            max_pain_strike = -1
                            for strike_price in strikes:
                                total_loss_at_strike = 0
                                for call_strike, oi in call_oi_map.items():
                                     if strike_price > call_strike: total_loss_at_strike += (strike_price - call_strike) * oi
                                for put_strike, oi in put_oi_map.items():
                                     if strike_price < put_strike: total_loss_at_strike += (put_strike - strike_price) * oi
                                if total_loss_at_strike < min_loss:
                                    min_loss = total_loss_at_strike
                                    max_pain_strike = strike_price
                            if max_pain_strike != -1: print(f"  預估最大痛點: ${max_pain_strike:.2f}")
                     except Exception as e_maxpain:
                         print(f"  計算最大痛點時出錯: {e_maxpain}")
        else:
             print("  缺少有效的最近到期日數據，無法進行文字分析。")

        # --- 繪製圖表 ---
        print("\n--- 繪製選擇權分佈圖 ---")
        if near_data is not None:
            plot_option_distribution_stacked_style(
                near_data, week_data, month_data,
                current_price,
                near_exp, week_exp, month_exp,
                ticker_symbol
            )
        else:
            print("  無最近到期日數據結構，無法繪製圖表。")

    except Exception as e:
        print(f"\n處理 {ticker_symbol} 時發生未預期的嚴重錯誤: {e}")
        traceback.print_exc()

    finally:
        print(f"\n--- 分析結束 ---")


# --- 主程式執行區塊 ---
if __name__ == "__main__":
    try:
        import google.colab
        print("偵測到 Google Colab 環境，執行 pip install...")
        !pip install yfinance pandas matplotlib -q
    except ImportError:
        print("非 Colab 環境，請確保已安裝 yfinance, pandas, matplotlib")

    # --- 匯入必要的函式庫 ---
    from datetime import datetime, timedelta
    from matplotlib.ticker import MaxNLocator # *** 確保 MaxNLocator 已匯入 ***
    import matplotlib.patches as mpatches
    from matplotlib.lines import Line2D
    import traceback

    # --- 獲取使用者輸入 ---
    print("\n========================================")
    input_ticker = input("請輸入欲分析的美股代號 (例如: AAPL, SPY, TSLA): ").strip().upper()
    print("========================================")

    # --- 執行分析 ---
    if input_ticker:
        analyze_option_chain(input_ticker)
    else:
        print("錯誤：未輸入股票代號，無法進行分析。")
