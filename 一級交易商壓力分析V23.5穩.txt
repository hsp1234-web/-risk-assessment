# @title 一級交易商壓力分析 (含 SOFR/利差/總持有/準備金/持有準備金比/MOVE/VIX/壓力指數) - API直接下載版 v23.5 (比率條件納入壓力指數)
# @markdown --- 基本設定 ---
# @markdown 請在此處輸入您的 FRED API Key。
fred_api_key = "77b0a570c6a17007e4f5af229c2aecc9" # @param {type:"string"}
# @markdown 請選擇或輸入您想分析的開始日期 (預設為 2017-01-01)。
start_date_input = "2017-01-01" # @param {type:"date"}
# @markdown 請輸入結束日期 (YYYY-MM-DD)。**執行時若此欄位為空或無效，將自動設為當天日期**。
end_date_input = "2025-04-16" # @param {"type":"date"}

# @markdown --- NY Fed 一級交易商持有量 API 下載連結 (多個, 含舊版 SBP) ---
# @markdown **提供多個涵蓋不同時間段的 API 連結。**
# @markdown **警告：舊版 SBP 數據很可能代表「淨持有部位」，與新版 SBN (Gross?) 定義不同！**
ny_fed_positions_urls = [
    "https://markets.newyorkfed.org/api/pd/get/SBN2024/timeseries/PDPOSGSC-L2_PDPOSGSC-G2L3_PDPOSGSC-G3L6_PDPOSGSC-G6L7_PDPOSGSC-G7L11_PDPOSGSC-G11L21_PDPOSGSC-G21.xlsx", # ~2024 至今
    "https://markets.newyorkfed.org/api/pd/get/SBN2022/timeseries/PDPOSGSC-L2_PDPOSGSC-G2L3_PDPOSGSC-G3L6_PDPOSGSC-G6L7_PDPOSGSC-G7L11_PDPOSGSC-G11L21_PDPOSGSC-G21.xlsx", # 2022-2024
    "https://markets.newyorkfed.org/api/pd/get/SBN2015/timeseries/PDPOSGSC-L2_PDPOSGSC-G2L3_PDPOSGSC-G3L6_PDPOSGSC-G6L7_PDPOSGSC-G7L11_PDPOSGSC-G11.xlsx",       # 2015-2022
    "https://markets.newyorkfed.org/api/pd/get/SBN2013/timeseries/PDPOSGSC-L2_PDPOSGSC-G2L3_PDPOSGSC-G3L6_PDPOSGSC-G6L7_PDPOSGSC-G7L11_PDPOSGSC-G11.xlsx",           # 2013-2014
    "https://markets.newyorkfed.org/api/pd/get/SBP2013/timeseries/PDPUSGCS3LNOP_PDPUSGCS36NOP_PDPUSGCS611NOP_PDPUSGCSM11NOP.xlsx",                                  # 2001-2013
    "https://markets.newyorkfed.org/api/pd/get/SBP2001/timeseries/PDPUSGCS5LNOP_PDPUSGCS5MNOP.xlsx"                                                                  # 1998-2001
]
# @markdown --- 舊版 SBP 文件欄位加總邏輯 ---
sbp2013_cols_to_sum = ['PDPUSGCS3LNOP', 'PDPUSGCS36NOP', 'PDPUSGCS611NOP', 'PDPUSGCSM11NOP']
sbp2001_cols_to_sum = ['PDPUSGCS5LNOP', 'PDPUSGCS5MNOP']

# @markdown --- 壓力指數計算加權 (可選調整) ---
# @markdown **單位：總持有量(GrossPos)和準備金(Reserves)以百萬美元(Millions USD)計，其權重用於壓力指數計算。**
rolling_window_days = 252 # @param {type:"integer"} # 指數計算回看期
# --- Set type to number for Colab form editing ---
weight_sofr_dev = 0.30 # @param {type:"number"}
weight_spread_inv = 0.15 # @param {type:"number"}
weight_gross_pos = 0.15 # @param {type:"number"}
weight_move = 0.20 # @param {type:"number"} # Adjusted default weight slightly
weight_vix = 0.10 # @param {type:"number"}
weight_pos_res_ratio = 0.10 # @param {type:"number"} # <<< 新增：持有/準備金比率高於閾值時的權重

# @markdown --- 指數平滑與著色 ---
smoothing_window_stress_index = 5 # @param {type:"integer"}
threshold_high_stress_color = 60 # @param {type:"number"}

# @markdown --- 持有/準備金 比率著色閾值 ---
threshold_ratio_color = 95 # @param {type:"number"} # 預設為 95

# ==============================================================================
# 1. 安裝/導入函式庫
# ==============================================================================
print("正在安裝/導入函式庫...")
try:
    import subprocess
    import sys
    print("正在嘗試 Colab 環境的套件安裝...")
    # <<< 取消註解以確保執行安裝 >>>
    !pip install --upgrade fredapi pandas matplotlib requests openpyxl yfinance numpy
    print("Colab 環境套件安裝結束。") # <<< 移除 (模擬)
except NameError: # Fallback for non-Colab
    import subprocess
    import sys
    try:
        print("正在嘗試非 Colab 環境的套件安裝...")
        # <<< 若在本地執行，請取消此行註解 >>>
        # subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "fredapi", "pandas", "matplotlib", "requests", "openpyxl", "yfinance", "numpy"])
        print("非 Colab 環境套件安裝結束。(本地執行需取消註解)") # <<< 說明本地執行需修改
    except subprocess.CalledProcessError as e:
        print(f"安裝套件時發生錯誤 (subprocess): {e}")
    except FileNotFoundError:
        print("錯誤：找不到 'pip' 指令。請確保 Python 和 pip 已正確安裝並在 PATH 中。")
except Exception as e:
     print(f"執行 pip install 指令時發生未預期錯誤: {e}")

# --- Attempt imports AFTER installation ---
try:
    import pandas as pd
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    from fredapi import Fred
    import numpy as np
    import datetime
    import json
    import requests
    import io
    import traceback
    import yfinance as yf
    import warnings
    try:
        import zoneinfo
        print("已成功導入 'zoneinfo' 模組。")
    except ImportError:
        zoneinfo = None # Set to None if not available
        print("警告: Python 3.9+ 的 'zoneinfo' 模組無法導入，將使用固定 UTC+8 時區。")
    warnings.filterwarnings('ignore', category=UserWarning, module='openpyxl')
    warnings.filterwarnings("ignore", category=FutureWarning, module="yfinance")
    print("函式庫導入完成。")
except ModuleNotFoundError as e:
    print(f"\n*** 嚴重錯誤：導入函式庫失敗: {e} ***")
    print("*** 請檢查上面的安裝日誌，確認所有必要的套件是否都已成功安裝。 ***")
    raise # Reraise error after logging

# ==============================================================================
# 繪圖函數定義 - Plot labels/titles in English
# ==============================================================================
def plot_results(final_df, plots_to_draw_flags, vol_index_fetched_name, vol_data_source,
                 smoothing_window_stress_index, threshold_high_stress_color, start_dt, end_dt,
                 reserves_plot_ok, ratio_plot_ok, threshold_ratio_color): # Added threshold_ratio_color
    """根據最終數據生成圖表"""
    print("\n--- Generating Plots ---")

    # Determine number of plots
    num_plots = sum(v for k, v in plots_to_draw_flags.items() if k != 'StressIndex')
    if reserves_plot_ok: num_plots += 1
    if ratio_plot_ok: num_plots += 1
    stress_index_plot_flag = plots_to_draw_flags.get('StressIndex', False)
    if stress_index_plot_flag: num_plots += 1

    if num_plots == 0:
        print("No data available for plotting.")
        return

    fig, axes = plt.subplots(num_plots, 1, figsize=(14, 4 * num_plots), sharex=True)
    if num_plots == 1: axes_list = [axes]
    else: axes_list = axes.flatten()
    plot_idx = 0

    # --- Plotting Order (Stress Index is plotted last) ---
    # SOFR
    if plots_to_draw_flags.get('SOFR'):
        ax = axes_list[plot_idx]; ax.plot(final_df.index, final_df['SOFR'], label='SOFR (%)', color='purple', linewidth=1.5);
        if 'SOFR_MA60' in final_df and final_df['SOFR_MA60'].notna().any(): ax.plot(final_df.index, final_df['SOFR_MA60'], label='SOFR 60D MA (%)', color='lightblue', linestyle='--', linewidth=1.0)
        ax.set_ylabel("Rate (%)"); ax.set_title("Secured Overnight Financing Rate (SOFR) & 60D MA"); ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6); plot_idx += 1
    # Spread
    if plots_to_draw_flags.get('Spread'):
        ax = axes_list[plot_idx]; ax.plot(final_df.index, final_df['Spread_10Y2Y']*100, label='10Y-2Y Spread (BPS)', color='orange', linewidth=1.5); ax.axhline(0, color='grey', linestyle='--', linewidth=0.8, label='0 BPS'); ax.set_ylabel("Spread (BPS)"); ax.set_title("US Treasury Yield Curve Slope (10Y - 2Y)"); ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6); plot_idx += 1
    # MOVE (Volatility)
    if plots_to_draw_flags.get('Volatility'):
        ax = axes_list[plot_idx]; plot_data_vol = final_df['Volatility_Index'].dropna()
        if not plot_data_vol.empty:
            print(f"  - Plotting MOVE Index ({len(plot_data_vol)} points)...")
            vol_label = f'{vol_index_fetched_name or "MOVE"} ({vol_data_source or "Yahoo"})'; vol_title = 'ICE BofA MOVE Index (Yahoo Finance)'
            ax.plot(plot_data_vol.index, plot_data_vol, label=vol_label, color='#00AEAE', linewidth=1.5)
            ax.set_ylabel("Index Level"); ax.set_title(vol_title); ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6);
            y_min = 0; max_val = plot_data_vol.max(); y_max = max(max_val * 1.1, y_min + 10) if pd.notna(max_val) else 100
            ax.set_ylim(bottom=y_min, top=y_max); print(f"      - MOVE Y-axis range: {y_min:.2f} to {y_max:.2f}")
            plot_idx += 1
        else: print("  - *** Warning: No valid MOVE data to plot. ***")
    # VIX
    if plots_to_draw_flags.get('VIX'):
        ax = axes_list[plot_idx]; plot_data_vix = final_df['VIX'].dropna()
        if not plot_data_vix.empty:
            print(f"  - Plotting VIX Index ({len(plot_data_vix)} points)...")
            ax.plot(plot_data_vix.index, plot_data_vix, label='VIX Index', color='magenta', linewidth=1.5)
            ax.set_ylabel("Index Level"); ax.set_title("CBOE Volatility Index (VIX)"); ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6);
            y_min = 0; max_val = plot_data_vix.max(); y_max = max(max_val * 1.1, y_min + 10) if pd.notna(max_val) else 50
            ax.set_ylim(bottom=y_min, top=y_max); print(f"      - VIX Y-axis range: {y_min:.2f} to {y_max:.2f}")
            plot_idx += 1
        else: print("  - *** Warning: No valid VIX data to plot. ***")
    # Gross Positions (Millions USD)
    if plots_to_draw_flags.get('GrossPos'):
        ax = axes_list[plot_idx]; plot_data_gross_pos = final_df['Total_Gross_Positions_Millions'].dropna()
        if not plot_data_gross_pos.empty:
            print(f"  - Plotting Total Positions (Millions USD) ({len(plot_data_gross_pos)} points)...")
            ax.plot(plot_data_gross_pos.index, plot_data_gross_pos, label='Total Positions (Millions USD)', color='green', linewidth=1.0, marker='.', markersize=2, linestyle='-')
            ax.set_ylabel("Positions (Millions USD)")
            ax.set_title("Primary Dealer Total Positions (Consolidated, Millions USD)")
            ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6);
            current_ylim = ax.get_ylim()
            ax.set_ylim(bottom=0, top=current_ylim[1])
            plot_idx += 1
        else: print("  - No valid Total Positions data to plot.")
    # Reserves (Millions USD)
    if reserves_plot_ok:
        ax = axes_list[plot_idx]
        plot_data_reserves = final_df['Reserves'].dropna()
        if not plot_data_reserves.empty:
            print(f"  - Plotting Total Reserves (Millions USD) ({len(plot_data_reserves)} points)...")
            ax.plot(plot_data_reserves.index, plot_data_reserves, label='Total Reserves (Millions USD)', color='goldenrod', linewidth=1.5)
            ax.set_ylabel("Reserves (Millions USD)")
            ax.set_title("Total Reserve Balances (WRESBAL, Millions USD)")
            ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6);
            current_ylim = ax.get_ylim()
            ax.set_ylim(bottom=0, top=current_ylim[1]) # Ensure y-axis starts at 0
            plot_idx += 1
        else:
            print("  - No valid Total Reserves data to plot.")
    # Positions / Reserves Ratio (Conditional Coloring)
    if ratio_plot_ok:
        ax = axes_list[plot_idx]
        plot_data_ratio = final_df['Pos_Res_Ratio'].dropna()
        if not plot_data_ratio.empty:
            print(f"  - Plotting Positions/Reserves Ratio ({len(plot_data_ratio)} points)...")
            color_below = '#FFBB66' # Color below threshold
            color_above = '#CC0000' # Color at or above threshold
            # Plot entire line with the "below" color first (ensures continuity)
            ax.plot(plot_data_ratio.index, plot_data_ratio, color=color_below, linewidth=1.5, label=f'Ratio (< {threshold_ratio_color})')
            # Overlay the "above" color where condition is met
            above_threshold = plot_data_ratio.where(plot_data_ratio >= threshold_ratio_color)
            ax.plot(above_threshold.index, above_threshold, color=color_above, linewidth=1.5, label=f'Ratio (>= {threshold_ratio_color})')
            # Add the threshold line
            ax.axhline(threshold_ratio_color, color='grey', linestyle='--', linewidth=1.0, label=f'Threshold ({threshold_ratio_color})')
            ax.set_ylabel("Ratio")
            ax.set_title("Primary Dealer Positions / Total Reserves Ratio")
            ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6);
            current_ylim_ratio = ax.get_ylim()
            ax.set_ylim(bottom=0, top=max(current_ylim_ratio[1]*1.05 if pd.notna(current_ylim_ratio[1]) else 1 , 1))
            plot_idx += 1
        else:
            print("  - No valid Positions/Reserves Ratio data to plot.")


    # Stress Index Plot - Moved to the end
    if stress_index_plot_flag: # Use the flag determined earlier
        ax = axes_list[plot_idx]; plot_data_stress = final_df['Dealer_Stress_Index'].dropna()
        if not plot_data_stress.empty:
            print(f"  - Plotting Stress Index ({len(plot_data_stress)} points)...")
            threshold_color = threshold_high_stress_color
            # Changed Legend Labels to English
            ax.plot(plot_data_stress.index, plot_data_stress, label=f'Stress Index (<{threshold_color})', color='lightpink', linewidth=2)
            high_stress_values = plot_data_stress.where(plot_data_stress >= threshold_color); ax.plot(plot_data_stress.index, high_stress_values, label=f'Stress Index (>= {threshold_color})', color='red', linewidth=2.5)
            ax.set_ylim(0, 110); ax.axhline(90, color='darkred', linestyle='--', linewidth=1.0, label='High (90+)'); ax.axhline(threshold_color, color='orange', linestyle='--', linewidth=1.0, label=f'Elevated ({threshold_color}+)'); ax.axhline(50, color='grey', linestyle=':', linewidth=0.8, label='Mid (50)');
            ax.set_ylabel("Index (1-100)")
            ax.set_title(f"Primary Dealer Stress Index ({'Smoothed' if smoothing_window_stress_index > 0 else 'Raw'} & Color Coded)")
            ax.legend(loc='upper left'); ax.grid(True, linestyle='--', alpha=0.6); plot_idx += 1
        else: print("  - No valid Stress Index data to plot.")


    # Formatting - Apply to the last axis plotted
    if plot_idx > 0: # Check if any plot was actually drawn
        last_ax = axes_list[plot_idx-1] # The last axis used
        highlight_dates = {'Repo Spike': ('2019-09-15', '2019-09-30'), 'COVID Crash': ('2020-03-01', '2020-04-15')}
        plot_start_dt_actual = final_df.index.min(); plot_end_dt_actual = final_df.index.max()
        if pd.notna(plot_start_dt_actual) and pd.notna(plot_end_dt_actual):
            for ax_h_idx in range(plot_idx): # Iterate through all axes that were used
                ax_h = axes_list[ax_h_idx]
                if len(ax_h.get_lines()) > 0 or len(ax_h.collections) > 0 :
                    try:
                        y_min_h, y_max_h = ax_h.get_ylim()
                        if pd.notna(y_min_h) and pd.notna(y_max_h) and y_min_h < y_max_h:
                            for label_h, (start_hl_str, end_hl_str) in highlight_dates.items():
                                try:
                                    start_hl=pd.to_datetime(start_hl_str); end_hl=pd.to_datetime(end_hl_str)
                                    if max(plot_start_dt_actual, start_hl) < min(plot_end_dt_actual, end_hl):
                                        visible_start=max(start_dt, start_hl); visible_end=min(end_dt, end_hl)
                                        if visible_start < visible_end:
                                            ax_h.axvspan(visible_start, visible_end, color='yellow', alpha=0.20, zorder=0)
                                            mid_date = visible_start + (visible_end - visible_start) / 2
                                            text_y_pos = y_min_h + (y_max_h - y_min_h) * 0.95
                                            ax_xlim_num = mdates.date2num(ax_h.get_xlim()); mid_date_num = mdates.date2num(mid_date)
                                            if ax_xlim_num[0] <= mid_date_num <= ax_xlim_num[1]:
                                                # Keep highlight labels in English
                                                ax_h.text(mid_date, text_y_pos, label_h, rotation=0, ha='center', va='top', fontsize=9, bbox=dict(boxstyle='round,pad=0.3', fc='yellow', alpha=0.5))
                                except Exception as e_highlight_inner: pass
                        else: pass
                    except Exception as e_get_ylim: pass
        # Apply date formatting only to the last axis
        last_ax.xaxis.set_major_locator(mdates.AutoDateLocator(minticks=5, maxticks=12)); last_ax.xaxis.set_major_formatter(mdates.ConciseDateFormatter(last_ax.xaxis.get_major_locator())); last_ax.set_xlabel("Date")
    fig.tight_layout(); plt.show()


# ==============================================================================
# 3. 設定/驗證日期
# ==============================================================================
try:
    if zoneinfo:
        taiwan_tz = zoneinfo.ZoneInfo("Asia/Taipei")
        print("使用 'zoneinfo' 設定時區為 Asia/Taipei。")
    else:
        taiwan_tz = datetime.timezone(datetime.timedelta(hours=8))
        print("使用固定 UTC+8 時區。")

    now_local = datetime.datetime.now(taiwan_tz)
    today_local_str = now_local.strftime('%Y-%m-%d')
    print(f"程式執行於當地時間: {now_local.strftime('%Y-%m-%d %H:%M:%S %Z')}")

    try:
        if not end_date_input: print("結束日期未輸入，自動設為今天。"); end_date_input = today_local_str
        else: pd.to_datetime(end_date_input); print(f"使用手動結束日期: {end_date_input}")
    except ValueError: print(f"結束日期 '{end_date_input}' 格式無效，自動設為今天。"); end_date_input = today_local_str

    try: pd.to_datetime(start_date_input)
    except ValueError: print(f"警告：開始日期 '{start_date_input}' 無效，使用預設 '2017-01-01'"); start_date_input = "2017-01-01"

except Exception as e:
    print(f"處理日期時出錯: {e}"); today_local_str = datetime.datetime.now().strftime('%Y-%m-%d')
    if not end_date_input: end_date_input = today_local_str
    if not start_date_input: start_date_input = "2017-01-01"
print("-" * 30)

# ==============================================================================
# 4. FRED API 驗證
# ==============================================================================
fred = None
if not fred_api_key or len(fred_api_key) < 32: print("錯誤：請提供有效的 FRED API Key。")
else:
    try: fred = Fred(api_key=fred_api_key); fred.get_series('SOFR', limit=1); print("FRED API 連線成功！")
    except Exception as e: print(f"FRED API 連線失敗: {e}\n請檢查您的 API Key 是否有效以及網路連線。"); fred = None
print("-" * 30)

# ==============================================================================
# 5. 日期範圍最終確認
# ==============================================================================
start_date = start_date_input; end_date = end_date_input; invalid_date = False
try:
    start_dt = pd.to_datetime(start_date); end_dt = pd.to_datetime(end_date)
    if start_dt >= end_dt: print(f"錯誤：開始日期 ({start_date}) 必須早於結束日期 ({end_date})。"); invalid_date = True
    else: print(f"最終分析時間範圍：{start_date} 到 {end_date}")
except ValueError: print(f"錯誤：無法解析日期 '{start_date}' 或 '{end_date}'。"); invalid_date = True
print("-" * 30)

# ==============================================================================
# --- 主要執行區塊 ---
# ==============================================================================
if fred and not invalid_date:

    # ==============================================================================
    # 6. 抓取 FRED 數據 - Added Reserves
    # ==============================================================================
    print("\n--- 正在抓取 FRED 數據 ---")
    fred_series_map = { # Added Reserves
        'SOFR': 'SOFR', 'DGS10': 'DGS10', 'DGS2': 'DGS2',
        'RRP': 'RRPONTSYD', 'VIX': 'VIXCLS',
        'Reserves': 'WRESBAL' # Fetch Reserves (Millions USD)
    }
    data_fred = pd.DataFrame()
    fetched_series_log = {}
    base_index = pd.date_range(start_date, end_date, freq='B')

    for name, series_id in fred_series_map.items():
        print(f"  - 正在抓取 FRED {name} ({series_id})...", end="")
        try:
            s = fred.get_series(series_id, start_date, end_date)
            s.index = pd.to_datetime(s.index).tz_localize(None)
            freq_str = pd.infer_freq(s.index); fill_method = 'ffill'
            if freq_str and ('W' in freq_str or 'M' in freq_str):
                print(f" ({freq_str}頻率，向前填充)...", end="")
                s = s.reindex(pd.date_range(start=s.index.min(), end=end_date, freq='D')).ffill()
                s = s.reindex(base_index, method=fill_method)
            elif not s.empty:
                s = s.reindex(base_index, method=fill_method)

            if s.empty or s.isna().all():
                print(" 失敗 (數據為空或全NaN)")
                fetched_series_log[name] = False
                data_fred[name] = pd.Series(dtype='float64', index=base_index)
            else:
                original_count = fred.get_series(series_id, start_date, end_date).count()
                aligned_count = s.count()
                print(f" 成功 (原始 {original_count} -> 對齊後 {aligned_count} 點)")
                data_fred[name] = s
                fetched_series_log[name] = True
        except Exception as e:
            print(f" 失敗: {e}")
            fetched_series_log[name] = False
            data_fred[name] = pd.Series(dtype='float64', index=base_index)

    core_data_ok = fetched_series_log.get('SOFR', False) or (fetched_series_log.get('DGS10', False) and fetched_series_log.get('DGS2', False))
    if not core_data_ok: print("*** 警告：未能抓取 SOFR 或 利差 (DGS10/DGS2) 數據。***")
    if not fetched_series_log.get('Reserves', False): print(f"*** 警告：未能抓取 總準備金 (WRESBAL) 數據。***")


    # ==============================================================================
    # 7. 獲取波動率指標 (^MOVE) - Using V20's method
    # ==============================================================================
    print(f"\n--- 正在獲取波動率指標 (^MOVE from Yahoo Finance) ---")
    vol_index_fetched_name = None; vol_data_source = None; volatility_ok = False
    volatility_series = pd.Series(dtype='float64')
    try:
        print("  - 嘗試抓取 ^MOVE (使用 V20 方法)...");
        move_data_yf = yf.download(['^MOVE'], start=start_date, end=end_date, progress=False, period='1d') # V20 call

        if not move_data_yf.empty and 'Close' in move_data_yf.columns:
            temp_series = pd.Series(dtype='float64')
            if isinstance(move_data_yf.columns, pd.MultiIndex):
                if ('Close', '^MOVE') in move_data_yf.columns: temp_series = move_data_yf[('Close', '^MOVE')]
                elif 'Close' in move_data_yf.columns.get_level_values(0) and '^MOVE' in move_data_yf.columns.get_level_values(1): temp_series = move_data_yf['Close']['^MOVE']
            elif 'Close' in move_data_yf.columns: temp_series = move_data_yf['Close']

            if not temp_series.empty:
                temp_series = pd.to_numeric(temp_series, errors='coerce').dropna()
                if not temp_series.empty:
                    volatility_series = temp_series; vol_index_fetched_name = '^MOVE'; vol_data_source = 'Yahoo Finance'; volatility_ok = True
                    volatility_series.index = pd.to_datetime(volatility_series.index).tz_localize(None)
                    print(f"  - 成功抓取 ^MOVE ({len(volatility_series)} 點)。")

        if not volatility_ok: print("  - *** 警告：^MOVE 數據為空或無效。***")
    except Exception as e_yf_move: print(f"  - *** 錯誤：抓取 ^MOVE 失敗: {e_yf_move} ***")

    # Merge MOVE data
    if volatility_ok and not volatility_series.empty:
        data_fred['Volatility_Index'] = volatility_series.reindex(data_fred.index, method='ffill')
        print(f"  - MOVE 指數已合併並對齊 (使用前向填充)。")
    else:
        data_fred['Volatility_Index'] = np.nan
        print("\n  ==> *** 警告：未能獲取 MOVE 指標。壓力指數計算可能受影響。***")
    if 'Volatility_Index' in data_fred.columns: print(f"  - 對齊後 MOVE 指數有效點數: {data_fred['Volatility_Index'].count()}")


    # ==============================================================================
    # 8. 抓取並整合 NY Fed 持有量數據 (Millions USD) - REVERTED TO MILLIONS
    # ==============================================================================
    print("\n--- 正在抓取並整合 NY Fed 持有量數據 (單位: 百萬美元) ---") # Unit specified
    print("*** 警告：合併 SBN(Gross?) 和 SBP(Net?) 數據！解釋需謹慎！ ***")
    all_positions_data = []; positions_fetch_success = False
    session = requests.Session()

    for i, url in enumerate(ny_fed_positions_urls):
        print(f"\n  [檔案 {i+1}/{len(ny_fed_positions_urls)}] 來源: {url.split('/')[-3]}...")
        try:
            print("      - 下載/讀取 Excel...", end=""); response_excel = session.get(url, timeout=90, headers={'User-Agent': 'Mozilla/5.0'}); response_excel.raise_for_status(); excel_content = io.BytesIO(response_excel.content); print(" 完成. 解析中...", end="")
            header_row = 3; date_col_name = 'Effective Date'
            try:
                df_test = pd.read_excel(excel_content, header=header_row); excel_content.seek(0)
                if 'Time Series' not in df_test.columns or 'Value (millions)' not in df_test.columns: header_row = 4; df_test = pd.read_excel(excel_content, header=header_row); excel_content.seek(0)
                if 'Time Series' not in df_test.columns or 'Value (millions)' not in df_test.columns: header_row = 0
            except Exception: header_row = 0; excel_content.seek(0)
            print(f" (使用標頭行 {header_row})...", end="")
            try:
                df_peek = pd.read_excel(excel_content, header=header_row, nrows=1); excel_content.seek(0)
                if date_col_name not in df_peek.columns: date_col_name = df_peek.columns[0]
            except Exception: date_col_name = 0; excel_content.seek(0)
            print(f" (日期列 '{date_col_name}')...", end="")
            data_positions_long = pd.read_excel(excel_content, header=header_row, index_col=date_col_name, parse_dates=True)
            if not isinstance(data_positions_long.index, pd.DatetimeIndex): data_positions_long.index = pd.to_datetime(data_positions_long.index, errors='coerce'); data_positions_long = data_positions_long.dropna(subset=[data_positions_long.index.name], axis=0)
            data_positions_long.index = data_positions_long.index.normalize()
            if 'Time Series' not in data_positions_long.columns or 'Value (millions)' not in data_positions_long.columns: print(" 錯誤：缺少必要欄位。跳過。"); continue
            if data_positions_long.empty: print(" 警告：數據為空。跳過。"); continue # Added skip for empty data
            print(f" 讀取成功 ({len(data_positions_long)} 行).")
            print("      - 轉換為寬格式...", end="")
            try:
                data_positions_long['Value (millions)'] = pd.to_numeric(data_positions_long['Value (millions)'], errors='coerce'); data_positions_long.dropna(subset=['Value (millions)'], inplace=True)
                data_positions_wide = pd.pivot_table(data_positions_long, index=data_positions_long.index, columns='Time Series', values='Value (millions)', aggfunc='mean')
                print(f" 成功 ({len(data_positions_wide)} 行 x {len(data_positions_wide.columns)} 欄).")
            except Exception as e_pivot: print(f" 錯誤：轉換格式失敗: {e_pivot}. 跳過."); continue
            # Summing Logic (Keep in Millions)
            if not data_positions_wide.empty:
                target_cols = []; source_type = "未知"
                if 'SBN' in url: source_type = "SBN"; target_cols = [c for c in data_positions_wide.columns if isinstance(c, str) and c.startswith('PDPOSGSC-')]
                elif 'SBP2013' in url: source_type = "SBP2013"; target_cols = sbp2013_cols_to_sum
                elif 'SBP2001' in url: source_type = "SBP2001"; target_cols = sbp2001_cols_to_sum
                if not target_cols: print(f"      - 警告：未找到加總欄位 ({source_type})。跳過加總。"); continue
                cols_to_sum_actual = [c for c in target_cols if c in data_positions_wide.columns]
                if not cols_to_sum_actual: print(f"      - 錯誤：目標欄位未找到 ({source_type})。跳過加總。"); continue
                if len(cols_to_sum_actual) < len(target_cols): missing_cols = set(target_cols) - set(cols_to_sum_actual); print(f"      - 警告：部分目標欄位未找到: {missing_cols}")
                print(f"      - 正在加總 {len(cols_to_sum_actual)} 個欄位 (單位: 百萬美元)...", end="") # Adjusted unit
                for col in cols_to_sum_actual: data_positions_wide[col] = pd.to_numeric(data_positions_wide[col], errors='coerce')
                # --- Keep in Millions (No Division) ---
                daily_total_millions = data_positions_wide[cols_to_sum_actual].sum(axis=1, skipna=False)
                original_count_before_drop = len(daily_total_millions)
                daily_total_millions = daily_total_millions.dropna(); daily_total_millions = daily_total_millions[daily_total_millions != 0]
                dropped_count = original_count_before_drop - len(daily_total_millions)
                if not daily_total_millions.empty:
                    all_positions_data.append(daily_total_millions); positions_fetch_success = True
                    print(f" 完成 ({len(daily_total_millions)} 筆有效數據, 移除了 {dropped_count} 筆 NaN/零值).")
                else: print(" *** 警告：此文件未能計算出有效的非零數據。***")
        except requests.exceptions.RequestException as e_req: print(f"      - *** 錯誤：下載文件時出錯: {e_req} ***")
        except pd.errors.EmptyDataError: print(f"      - *** 錯誤：Excel 文件為空或無法解析。 ***")
        except ValueError as e_val: print(f"      - *** 錯誤：處理數據時出現數值錯誤: {e_val} ***")
        except Exception as e: print(f"      - *** 錯誤：處理此文件時發生未預期錯誤: {e} ***"); print(traceback.format_exc())

    # Consolidate All Position Data
    final_positions_series = pd.Series(dtype='float64')
    if all_positions_data:
        print("\n--- 合併持有量數據 ---")
        try:
            combined_positions = pd.concat(all_positions_data).sort_index()
            # Use groupby().last() to handle duplicates from different files/time periods
            final_positions_series = combined_positions.groupby(level=0).last()
            final_positions_series.name = 'Total_Gross_Positions_Millions' # Use Millions Name
            # Final check for zeros/NaNs after consolidation
            final_positions_series = final_positions_series[final_positions_series != 0].dropna()
            if not final_positions_series.empty:
                print(f"合併完成 ({len(final_positions_series)} 筆, {final_positions_series.index.min().date()} to {final_positions_series.index.max().date()}, 單位: 百萬美元)") # Adjusted unit message
            else: print("警告：合併後數據為空或全為零值。"); positions_fetch_success = False
        except Exception as e_concat: print(f"*** 錯誤：合併持有量數據時出錯: {e_concat} ***"); positions_fetch_success = False
    else: print("\n錯誤：未能成功處理任何持有量數據文件。"); positions_fetch_success = False


    # ==============================================================================
    # 9. 合併所有數據源 - Using Millions for Positions
    # ==============================================================================
    print("\n--- 合併所有數據源 ---")
    data_merged = data_fred.copy()
    print(f"  - 起始 FRED 數據 ({len(data_merged)} 行, 索引: {data_merged.index.min().date()} to {data_merged.index.max().date()})")
    # Rename RRP for clarity
    if 'RRP' in data_merged.columns:
        data_merged.rename(columns={'RRP': 'RRP_Amount_Billions'}, inplace=True) # RRP is typically in Billions
        print(f"  - 已重命名 RRP -> RRP_Amount_Billions")
    else:
        data_merged['RRP_Amount_Billions'] = np.nan # Ensure column exists if fetch failed
    # Placeholder for SRF (Standing Repo Facility), assuming 0 unless data source added later
    data_merged['SRF_Amount_Billions'] = 0.0
    # Merge Primary Dealer Positions (Millions)
    if positions_fetch_success and not final_positions_series.empty:
        print(f"  - 合併總持有量 ({len(final_positions_series)} 行, 單位: 百萬美元)") # Use Millions Name
        # Merge using left join on the index
        data_merged = pd.merge(data_merged, final_positions_series.to_frame(), left_index=True, right_index=True, how='left')
        merged_pos_count = data_merged['Total_Gross_Positions_Millions'].count(); print(f"    > 合併後持有量有效點數: {merged_pos_count}")
        # Forward fill gaps in position data (common practice for weekly/infrequent position data)
        data_merged['Total_Gross_Positions_Millions'] = data_merged['Total_Gross_Positions_Millions'].ffill()
        filled_pos_count = data_merged['Total_Gross_Positions_Millions'].count(); print(f"    > 向前填充後持有量有效點數: {filled_pos_count}")
    else:
        print("  - 未能合併總持有量 (數據缺失或處理失敗)")
        data_merged['Total_Gross_Positions_Millions'] = np.nan # Use Millions Name, ensure column exists

    # Ensure Volatility Index column exists if fetch failed
    if 'Volatility_Index' not in data_merged.columns:
        data_merged['Volatility_Index'] = np.nan
        print("  - Volatility_Index 欄位不存在，已創建空欄位。")

    # Final Alignment & Filtering
    data_merged.index = pd.to_datetime(data_merged.index) # Ensure index is datetime
    data_merged = data_merged.sort_index() # Sort by date
    # Reindex to ensure all business days in the final range are present
    final_index = pd.date_range(start=start_date, end=end_date, freq='B')
    original_rows_before_reindex = len(data_merged)
    data_merged = data_merged.reindex(final_index)
    print(f"  - 重新對齊到最終業務日索引 ({start_date} to {end_date})")
    print(f"    > 行數變化: {original_rows_before_reindex} -> {len(data_merged)}")

    # Filter data to the requested date range exactly AFTER reindexing
    if not invalid_date: # Only filter if dates were valid
        data_merged = data_merged[start_date:end_date]

    # Final check for empty dataframe
    if data_merged.empty:
        print("*** 警告：最終數據框 data_merged 在合併與對齊後為空。 ***")
    else:
        print(f"最終合併數據範圍: {data_merged.index.min().date()} to {data_merged.index.max().date()} ({len(data_merged)} 行)")
        print("  - 合併後各欄位 NaN 統計:")
        for col in data_merged.columns:
            nan_count = data_merged[col].isna().sum()
            if nan_count > 0 and len(data_merged) > 0 : print(f"    > {col}: {nan_count} / {len(data_merged)} ({nan_count/len(data_merged):.1%}) NaN")


    # ==============================================================================
    # 10. 計算指標 & 壓力指數 - Added Ratio calculation and conditional contribution to index
    # ==============================================================================
    print("\n--- 計算指標與壓力指數 ---")
    if data_merged.empty:
        print("錯誤：合併後的數據為空，無法進行計算。")
        final_df = pd.DataFrame()
    else:
        final_df = data_merged.copy()
        # --- Initialize flags ---
        stress_index_calculated = False
        sofr_ok = False; sofr_dev_ok = False; spread_calculated_ok = False
        gross_pos_ok = False; volatility_ok = False; vix_ok = False
        reserves_plot_ok = False # Flag for reserves plot specifically
        ratio_calculated_ok = False # Flag for ratio

        # Ensure Numeric Types & Check Availability
        cols_to_numeric = [ # Use Millions for Positions, original Reserves
            'Total_Gross_Positions_Millions', 'Volatility_Index', 'VIX',
            'DGS10', 'DGS2', 'SOFR', 'Reserves', 'RRP_Amount_Billions'
        ]
        print("  - 檢查並轉換數值欄位...")
        for col in cols_to_numeric:
            if col in final_df.columns:
                original_non_nan = final_df[col].notna().sum(); final_df[col] = pd.to_numeric(final_df[col], errors='coerce'); final_non_nan = final_df[col].notna().sum()
                if original_non_nan != final_non_nan: print(f"    > {col}: 轉換後有效數值點 {final_non_nan} (原 {original_non_nan})")
            else: print(f"    > 欄位 {col} 不存在."); final_df[col] = np.nan

        # Check availability (if ANY non-NaN data exists for the series)
        sofr_ok = final_df['SOFR'].notna().any()
        gross_pos_ok = final_df['Total_Gross_Positions_Millions'].notna().any() # Check Millions
        volatility_ok = final_df['Volatility_Index'].notna().any()
        vix_ok = final_df['VIX'].notna().any()
        reserves_plot_ok = final_df['Reserves'].notna().any() # Check original Reserves (Millions) for plotting

        # Calculate Basic Indicators
        # Spread
        if 'DGS10' in final_df.columns and 'DGS2' in final_df.columns and final_df['DGS10'].notna().any() and final_df['DGS2'].notna().any():
            final_df['Spread_10Y2Y'] = final_df['DGS10'] - final_df['DGS2']; spread_calculated_ok = final_df['Spread_10Y2Y'].notna().any()
            print(f"  - 利差 (10Y-2Y) 計算: {'成功' if spread_calculated_ok else '失敗/缺失'} ({final_df['Spread_10Y2Y'].count()} 點)")
        else: final_df['Spread_10Y2Y'] = np.nan; spread_calculated_ok = False; print(f"  - 利差 (10Y-2Y) 計算: 失敗 (DGS10 或 DGS2 缺失)")

        # SOFR Deviation
        if sofr_ok:
            min_periods_ma = 30 # Require at least 30 points for a meaningful MA
            if len(final_df['SOFR'].dropna()) >= min_periods_ma:
                final_df['SOFR_MA60'] = final_df['SOFR'].rolling(window=60, min_periods=min_periods_ma).mean(); final_df['SOFR_Dev'] = final_df['SOFR'] - final_df['SOFR_MA60']; sofr_dev_ok = final_df['SOFR_Dev'].notna().any()
                print(f"  - SOFR 偏差 (vs 60D MA) 計算: {'成功' if sofr_dev_ok else '失敗/缺失'} ({final_df['SOFR_Dev'].count()} 點)")
            else: final_df['SOFR_Dev'] = np.nan; final_df['SOFR_MA60'] = np.nan; sofr_dev_ok = False; print(f"  - SOFR 偏差 計算: 失敗 (數據點不足 {min_periods_ma} )")
        else: final_df['SOFR_Dev'] = np.nan; final_df['SOFR_MA60'] = np.nan; sofr_dev_ok = False; print(f"  - SOFR 偏差 計算: 失敗 (SOFR 數據缺失)")

        # Calculate Positions/Reserves Ratio
        if gross_pos_ok and reserves_plot_ok: # Need both for the ratio
            print("  - 計算 持有量/準備金 比率...")
            # Avoid division by zero or near-zero; replace with NaN before division
            reserves_safe = final_df['Reserves'].replace(0, np.nan)
            final_df['Pos_Res_Ratio'] = final_df['Total_Gross_Positions_Millions'] / reserves_safe
            ratio_calculated_ok = final_df['Pos_Res_Ratio'].notna().any() # Check if calculation resulted in any valid numbers
            if ratio_calculated_ok:
                 print(f"    > 計算完成 ({final_df['Pos_Res_Ratio'].count()} 點)")
            else:
                 print("    > 計算失敗或結果全為 NaN/inf")
                 if 'Pos_Res_Ratio' not in final_df: final_df['Pos_Res_Ratio'] = np.nan # Ensure column exists
        else:
            print("  - 計算 持有量/準備金 比率: 失敗 (持有量或準備金數據缺失)")
            final_df['Pos_Res_Ratio'] = np.nan # Ensure column exists even if calculation fails

        print(f"  - 指標可用性: SOFR={sofr_ok}, SOFR_Dev={sofr_dev_ok}, Spread={spread_calculated_ok}, GrossPos(Mn)={gross_pos_ok}, MOVE={volatility_ok}, VIX={vix_ok}, Reserves(Mn)={reserves_plot_ok}, Ratio={ratio_calculated_ok}") # Added Ratio status

        # Calculate Stress Index
        print("\n  - 計算壓力指數...")
        column_mapping = { # Map internal names to DataFrame columns
            'sofr_dev': 'SOFR_Dev', 'spread_inv': 'Spread_10Y2Y',
            'gross_pos': 'Total_Gross_Positions_Millions', 'move': 'Volatility_Index', 'vix': 'VIX',
            'pos_res_ratio': 'Pos_Res_Ratio' # Added ratio mapping
        }
        component_availability = { # Check if data for each component is available
            'sofr_dev': sofr_dev_ok, 'spread_inv': spread_calculated_ok,
            'gross_pos': gross_pos_ok, 'move': volatility_ok, 'vix': vix_ok,
            'pos_res_ratio': ratio_calculated_ok # Added ratio availability
        }
        # --- Use weight variables defined in markdown ---
        weights = {
            'sofr_dev': weight_sofr_dev, 'spread_inv': weight_spread_inv,
            'gross_pos': weight_gross_pos, 'move': weight_move, 'vix': weight_vix,
            'pos_res_ratio': weight_pos_res_ratio # Added ratio weight
        }
        # Filter active components based on availability and non-zero weight
        active_components = {k: w for k, w in weights.items() if component_availability.get(k, False) and w > 0}
        total_weight = sum(active_components.values())

        if total_weight > 0:
            weights_normalized = {k: v / total_weight for k, v in active_components.items()}
            print(f"    - 指數計算基於 (正規化權重): {', '.join([f'{k}({w:.1%})' for k, w in weights_normalized.items()])}")

            # Identify necessary columns in the DataFrame for active components
            active_columns = [column_mapping[key] for key in active_components.keys() if key in column_mapping]
            active_columns_exist = [col for col in active_columns if col in final_df.columns]

            # Check if enough overlapping data points exist for rolling calculations
            min_data_points_for_index = int(rolling_window_days * 0.6); sufficient_data = False
            if active_columns_exist:
                non_nan_rows = final_df.dropna(subset=active_columns_exist, how='any')
                if len(non_nan_rows) >= min_data_points_for_index: sufficient_data = True
                else: print(f"    - *** 警告：共同有效數據點 ({len(non_nan_rows)}) 不足 (需要約 {min_data_points_for_index} 點)。無法計算滾動排名。***"); print(f"      檢查的欄位: {cols_exist_in_df}")
            else: print(f"    - *** 警告：無有效數據欄位可供計算指數。***")

            if sufficient_data:
                window = int(rolling_window_days); window = max(window, 5); min_periods_rank = int(window * 0.5); min_periods_rank = max(min_periods_rank, 2)
                print(f"    - 計算滾動排名 (窗口: {window}天, 最小期: {min_periods_rank}天)...")
                perc_ranks = pd.DataFrame(index=final_df.index)

                # Calculate percentile ranks for standard components
                if 'sofr_dev' in active_components: perc_ranks['sofr_dev'] = final_df[column_mapping['sofr_dev']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True); print(f"      > sofr_dev rank: {perc_ranks['sofr_dev'].count()} non-NaN")
                if 'spread_inv' in active_components: spread_perc = final_df[column_mapping['spread_inv']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True); perc_ranks['spread_inv'] = 1.0 - spread_perc; print(f"      > spread_inv rank: {perc_ranks['spread_inv'].count()} non-NaN") # Invert spread rank
                if 'gross_pos' in active_components: perc_ranks['gross_pos'] = final_df[column_mapping['gross_pos']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True); print(f"      > gross_pos rank: {perc_ranks['gross_pos'].count()} non-NaN")
                if 'move' in active_components: perc_ranks['move'] = final_df[column_mapping['move']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True); print(f"      > move rank: {perc_ranks['move'].count()} non-NaN")
                if 'vix' in active_components: perc_ranks['vix'] = final_df[column_mapping['vix']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True); print(f"      > vix rank: {perc_ranks['vix'].count()} non-NaN")

                # Calculate rank for pos_res_ratio (needed even if only used conditionally)
                if 'pos_res_ratio' in active_components:
                    perc_ranks['pos_res_ratio'] = final_df[column_mapping['pos_res_ratio']].rolling(window=window, min_periods=min_periods_rank).rank(pct=True)
                    print(f"      > pos_res_ratio rank: {perc_ranks['pos_res_ratio'].count()} non-NaN")

                # Combine ranks using normalized weights
                combined_score_01 = pd.Series(0.0, index=final_df.index)

                # Create condition mask for pos_res_ratio
                ratio_high_condition = (final_df['Pos_Res_Ratio'] >= threshold_ratio_color).astype(float) # 1.0 if high, 0.0 if low/NaN

                for name, weight in weights_normalized.items():
                    if name in perc_ranks.columns:
                        rank_series = perc_ranks[name].fillna(0.5) # Fill NaNs with neutral 0.5
                        # Apply conditional weighting for pos_res_ratio
                        if name == 'pos_res_ratio':
                            combined_score_01 += rank_series * ratio_high_condition * weight
                            # Optional: print how many points met the condition for this component's contribution
                            # print(f"      > {name} contributed for {int(ratio_high_condition.sum())} periods.")
                        else:
                            combined_score_01 += rank_series * weight
                    else:
                        print(f"      > 警告: {name} 的排名未計算或不存在，在加權總和中忽略。")


                # Scale to 1-100 range
                final_df['Dealer_Stress_Index_Raw'] = (1 + combined_score_01 * 99).clip(1, 100)
                raw_index_non_nan = final_df['Dealer_Stress_Index_Raw'].notna().sum()
                print(f"    - 原始指數計算完成 ({raw_index_non_nan} 點)。")

                # Smooth the index if requested
                if smoothing_window_stress_index > 1:
                    min_periods_smooth = max(1, int(smoothing_window_stress_index * 0.5))
                    final_df['Dealer_Stress_Index'] = final_df['Dealer_Stress_Index_Raw'].rolling(window=smoothing_window_stress_index, min_periods=min_periods_smooth, center=True).mean().clip(1, 100)
                    print(f"    - 平滑指數 (窗口: {smoothing_window_stress_index} 天, 中心)...")
                else:
                    final_df['Dealer_Stress_Index'] = final_df['Dealer_Stress_Index_Raw']
                    print(f"    - 未執行指數平滑 (窗口 <= 1)。")

                # Final check for stress index calculation success
                if final_df['Dealer_Stress_Index'].notna().any():
                     stress_index_calculated = True
                     print(f"    - 最終壓力指數計算完成 ({final_df['Dealer_Stress_Index'].count()} 點)。")
                else:
                     print("    - *** 警告：指數計算結果 (平滑後) 均為 NaN。***")
                     if 'Dealer_Stress_Index' not in final_df: final_df['Dealer_Stress_Index'] = np.nan
                     if 'Dealer_Stress_Index_Raw' not in final_df: final_df['Dealer_Stress_Index_Raw'] = np.nan
            else: # Not sufficient data
                 final_df['Dealer_Stress_Index'] = np.nan; final_df['Dealer_Stress_Index_Raw'] = np.nan
        else: # Total weight is zero
             print("    - *** 警告：無可用指標或所有權重為零，無法計算壓力指數。***")
             final_df['Dealer_Stress_Index'] = np.nan; final_df['Dealer_Stress_Index_Raw'] = np.nan


    # ==============================================================================
    # 11. 視覺化 - Pass ratio_calculated_ok and threshold_ratio_color
    # ==============================================================================
    if not final_df.empty:
        print("\n--- 準備繪圖數據 ---")
        # Flags for individual plots (excluding reserves and ratio, handled separately)
        plots_to_draw_flags = {
            'SOFR': sofr_dev_ok, 'Spread': spread_calculated_ok, 'Volatility': volatility_ok,
            'VIX': vix_ok, 'GrossPos': gross_pos_ok,
            'StressIndex': stress_index_calculated and final_df['Dealer_Stress_Index'].notna().any()
        }
        # Filter flags dictionary to only include True flags (plots to be drawn)
        # Keep StressIndex flag separate as it's plotted last
        plots_to_draw_flags_filtered = {k: v for k, v in plots_to_draw_flags.items() if v and k != 'StressIndex'}

        # Check if there's anything to plot at all
        if plots_to_draw_flags_filtered or reserves_plot_ok or ratio_calculated_ok or plots_to_draw_flags.get('StressIndex'):
            # Ensure start/end dates are datetime objects for plotting functions
            if not isinstance(start_dt, datetime.datetime): start_dt = pd.to_datetime(start_date)
            if not isinstance(end_dt, datetime.datetime): end_dt = pd.to_datetime(end_date)

            # Call the plotting function, passing all necessary flags
            plot_results(final_df, plots_to_draw_flags, # Pass the original flags dict here
                         vol_index_fetched_name, vol_data_source,
                         smoothing_window_stress_index, threshold_high_stress_color,
                         start_dt, end_dt,
                         reserves_plot_ok, ratio_calculated_ok, threshold_ratio_color) # Pass threshold_ratio_color
        else:
            print("\n沒有可繪製的數據 (所有指標均缺失或計算失敗)。")

        # ==============================================================================
        # 12. 數據預覽 - Added Ratio
        # ==============================================================================
        print("\n--- 數據預覽 (最近 5 筆有效數據) ---")
        cols_to_preview = []
        # Map internal names to column names and availability flags
        cols_map_preview = { # Use Millions Names
            'SOFR': ('SOFR', sofr_ok), 'Spread': ('Spread_10Y2Y', spread_calculated_ok),
            'MOVE': ('Volatility_Index', volatility_ok), 'VIX': ('VIX', vix_ok),
            'GrossPos': ('Total_Gross_Positions_Millions', gross_pos_ok),
            'Reserves': ('Reserves', reserves_plot_ok),
            'Ratio': ('Pos_Res_Ratio', ratio_calculated_ok), # Added Ratio
            'StressIndex': ('Dealer_Stress_Index', stress_index_calculated),
            'StressIndexRaw': ('Dealer_Stress_Index_Raw', stress_index_calculated)
        }
        # Build list of columns to show based on availability
        for key, (col_name, flag) in cols_map_preview.items():
             if flag and col_name in final_df.columns: cols_to_preview.append(col_name)

        if cols_to_preview:
            try: # Get last 5 rows with any data in the selected columns
                preview_df = final_df[cols_to_preview].dropna(how='all').tail()
            except IndexError: # Handle cases with less than 5 rows
                 preview_df = final_df[cols_to_preview].dropna(how='all')

            if not preview_df.empty:
                # Define formatters for specific columns
                formatters = {}
                if 'Spread_10Y2Y' in preview_df.columns: formatters['Spread_10Y2Y'] = lambda x: f"{x*100:.1f} bps" if pd.notna(x) else "NaN"
                if 'Total_Gross_Positions_Millions' in preview_df.columns: formatters['Total_Gross_Positions_Millions'] = lambda x: f"${x:,.0f} Mn" if pd.notna(x) else "NaN"
                if 'Reserves' in preview_df.columns: formatters['Reserves'] = lambda x: f"${x:,.0f} Mn" if pd.notna(x) else "NaN"
                if 'Dealer_Stress_Index' in preview_df.columns: formatters['Dealer_Stress_Index'] = '{:.2f}'.format
                if 'Dealer_Stress_Index_Raw' in preview_df.columns: formatters['Dealer_Stress_Index_Raw'] = '{:.2f}'.format
                if 'Volatility_Index' in preview_df.columns: formatters['Volatility_Index'] = '{:.2f}'.format
                if 'VIX' in preview_df.columns: formatters['VIX'] = '{:.2f}'.format
                if 'SOFR' in preview_df.columns: formatters['SOFR'] = '{:.3f}%'.format
                if 'Pos_Res_Ratio' in preview_df.columns: formatters['Pos_Res_Ratio'] = '{:.2f}'.format # Formatter for Ratio

                # Display using IPython display if available, otherwise print
                try:
                    from IPython.display import display
                    display(preview_df.style.format(formatters, na_rep='NaN'))
                except ImportError:
                     print(preview_df.to_string(formatters=formatters))
            else: print("無數據可供預覽 (過濾後為空)。")
        else: print("沒有可供預覽的數據欄位。")


        # ==============================================================================
        # 13. 分析提示 / 指數說明 - Added Ratio component mention
        # ==============================================================================
        # Only print notes if plots were generated
        if plots_to_draw_flags or reserves_plot_ok or ratio_calculated_ok:
            print("\n--- 分析提示與指標說明 ---")
            # Display latest stress index value and status
            if stress_index_calculated and 'Dealer_Stress_Index' in final_df.columns :
                latest_stress = final_df['Dealer_Stress_Index'].dropna()
                if not latest_stress.empty:
                    latest_date = latest_stress.index[-1].strftime('%Y-%m-%d'); latest_value = latest_stress.iloc[-1]
                    smoothing_status = f"已平滑 ({smoothing_window_stress_index}日)" if smoothing_window_stress_index > 1 else "未平滑"
                    print(f"最新壓力指數 ({latest_date}, {smoothing_status}): {latest_value:.2f}")
                    if latest_value >= 90: print("  - 狀態：高壓力 (90+)")
                    elif latest_value >= threshold_high_stress_color: print(f"  - 狀態：壓力升高 ({threshold_high_stress_color}+)")
                    elif latest_value >= 50: print("  - 狀態：中等水平 (50-)")
                    else: print("  - 狀態：低壓力 (<50)")
                else: print("壓力指數已計算，但無最新有效值可顯示。")

            # Describe stress index components and weights
            if stress_index_calculated and total_weight > 0:
                weights_desc = { # Use Millions label
                    'SOFR偏差': weights_normalized.get('sofr_dev',0), '利差反轉': weights_normalized.get('spread_inv',0),
                    '總持有(Mn)': weights_normalized.get('gross_pos',0), 'MOVE': weights_normalized.get('move',0),
                    'VIX': weights_normalized.get('vix', 0),
                    f'持有/準備金比率(>{threshold_ratio_color})': weights_normalized.get('pos_res_ratio', 0) # Updated Ratio component description
                }
                weights_str = ", ".join([f"{k}({v:.0%})" for k, v in weights_desc.items() if v > 0])
                print(f"\n壓力指數(1-100)基於過去 {rolling_window_days}日滾動排名，綜合指標: {weights_str}")
                if 'pos_res_ratio' in weights_normalized: print(f"  - 注意：持有/準備金比率僅在其高於 {threshold_ratio_color} 時貢獻權重。") # Updated explanation for conditional weight
                if smoothing_window_stress_index > 1: print(f"  - 結果已用 {smoothing_window_stress_index}日移動平均中心平滑。")
            elif plots_to_draw_flags.get('StressIndex'): print("\n壓力指數因數據不足或其他原因未成功計算或無有效值。") # Use .get()

            # Mention included volatility indices and reserves
            if plots_to_draw_flags.get('Volatility'): print(f"* 債券波動率(MOVE)已納入指數計算 (權重: {weights.get('move', 0):.0%})。") # Use .get()
            if plots_to_draw_flags.get('VIX'): print(f"* VIX 指數已納入指數計算 (權重: {weights.get('vix', 0):.0%})。") # Use .get()
            if reserves_plot_ok: print(f"* 總準備金(WRESBAL)圖表已繪製。單位: 百萬美元 (Millions USD)。")
            if ratio_calculated_ok: print(f"* 持有量/準備金 比率圖表已繪製 (閾值 {threshold_ratio_color})。")

            # General Notes
            print("\n注意：")
            print("- 指數衡量相對歷史壓力。權重可在頂部調整。")
            print("- **總持有量數據整合自 NY Fed API (單位: 百萬美元)，可能混合 Gross/Net，解釋需謹慎！**")
            res_freq = '未知'
            if fetched_series_log.get('Reserves'):
                try: # Attempt to get frequency dynamically
                    res_freq = pd.infer_freq(fred.get_series('WRESBAL', limit=5).index) or '週頻率(未知結束日)'
                except: pass # Ignore errors fetching frequency
            print(f"- 準備金數據 (WRESBAL) 為 {res_freq}，已向前填充至業務日。")
            print("- 結果僅供觀察參考，不構成投資建議。")

    else: # If final_df was empty
         print("\n--- 無法生成圖表或預覽 (最終數據框為空) ---")


# --- Error Handling for Script Initialization ---
elif invalid_date:
    print("-" * 30)
    print("\n錯誤：日期輸入無效，程式未執行。")
elif not fred:
    print("-" * 30)
    print("\n錯誤：FRED API 未成功初始化，程式未執行。")

print("\n--- 程式執行完畢 ---")
